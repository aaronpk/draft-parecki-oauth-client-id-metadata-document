{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-09-03T00:30:51.642649+00:00",
  "repo": "aaronpk/draft-parecki-oauth-client-id-metadata-document",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 3,
      "id": "I_kwDOL_Xevs6KwO1L",
      "title": "Caching recommendations for the metadata document",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/3",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "https://drafts.aaronpk.com/draft-parecki-oauth-client-id-metadata-document/draft-parecki-oauth-client-id-metadata-document.html#name-metadata-caching\r\n\r\nProbably makes sense to respect the HTTP cache headers from the metadata URL.\r\n\r\nThe AS should probably also have its own min/max cache lifetime policy. Not sure if we want to recommend something explicit here though since it might depend on the particular deployment.",
      "createdAt": "2024-05-31T13:56:13Z",
      "updatedAt": "2024-05-31T13:56:13Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 4,
      "id": "I_kwDOL_Xevs6KwQmr",
      "title": "need more warnings about OAuth phishing attacks",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/4",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "https://drafts.aaronpk.com/draft-parecki-oauth-client-id-metadata-document/draft-parecki-oauth-client-id-metadata-document.html#name-oauth-phishing-attacks\r\n\r\nThis section should be more explicit about the dangers of app impersonation through the metadata document.\r\n\r\nFor example, a client hosting a metadata document at `https://goooooooogle.com/metadata` could put an app name and logo icon of \"Google Docs\" in the metadata, impersonating a client that is actually `https://google.com/metadata`, potentially leading to authorizing the wrong client.\r\n\r\nWe should place a stronger recommendation around displaying the hostname of the actual `client_id` to the end user to help prevent this kind of phishing.",
      "createdAt": "2024-05-31T13:58:55Z",
      "updatedAt": "2024-06-10T11:58:54Z",
      "closedAt": null,
      "comments": [
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "Aren't there also some phishing attacks risks when allowing the redirect_uris to be on any domain? If a client does not properly encode the `state` param (like they should!), they could interpret a redirection that was initiated by an attacker as a legitimate authorization callback.",
          "createdAt": "2024-06-07T13:32:08Z",
          "updatedAt": "2024-06-07T13:32:08Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "The approach towards which I'm leaning is to require the client_uri to be the \"parent\" url of the `client_id` (the same url but without the last path segment and no query string), and require that all `redirect_uris` start with `<client_uri>/`.\r\n\r\nAlso, we don't plan on showing the `icon_uri` for unknown clients. We might put in place a mechanism to allow devs to add their clients to the allow listed clients.",
          "createdAt": "2024-06-07T14:14:20Z",
          "updatedAt": "2024-06-07T14:14:20Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The approach towards which I'm leaning is to require the client_uri to be the \"parent\" url of the `client_id` (the same url but without the last path segment and no query string), and require that all `redirect_uris` start with `<client_uri>/`.\r\n> \r\n> Also, we don't plan on showing the `icon_uri` for unknown clients. We might put in place a mechanism to allow devs to add their clients to the allow listed clients.\r\n\r\nThat breaks custom app redirect protocols",
          "createdAt": "2024-06-07T19:21:44Z",
          "updatedAt": "2024-06-07T19:21:44Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "Yeah, I'm only doing this for HTTP based uris.",
          "createdAt": "2024-06-10T07:00:15Z",
          "updatedAt": "2024-06-10T07:00:15Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This would also break HTTP cases where you want the app at `https://app.myservice.example` but the marketing/about site is `https://myservice.example`",
          "createdAt": "2024-06-10T07:23:22Z",
          "updatedAt": "2024-06-10T07:23:22Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In the case of BlueSky, you could also extend the metadata you store to include one of your bluesky DIDs, which would be used in preference over `icon_uri`, and if that client metadata document were then used against say, a mastodon server, then it'd just ignore the additional property it doesn't understand ",
          "createdAt": "2024-06-10T07:26:37Z",
          "updatedAt": "2024-06-10T07:26:37Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "I realize now that adding restrictions on the `client_uri` or `redirect_uris` is probably worthless, as these could indeed be \"valid\" (wrt to those restrictions) while performing a 3xx redirect when visited.\r\n\r\nRegarding the icon, I am not sure how using an account's profile picture (through its DID) would allow avoiding impersonation of well established companies.",
          "createdAt": "2024-06-10T09:12:14Z",
          "updatedAt": "2024-06-10T09:12:14Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It wouldn't necessarily prevent, but you'd have an on-platform identity linked which could then help with moderation ",
          "createdAt": "2024-06-10T11:58:53Z",
          "updatedAt": "2024-06-10T11:58:53Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOL_Xevs6Lb2P_",
      "title": "Compare & contrast with draft-looker-oauth-client-discovery",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/5",
      "state": "OPEN",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://www.ietf.org/archive/id/draft-looker-oauth-client-discovery-01.html\r\n\r\nThese a similar, but that I-D uses bare hostnames with a well-known path, instead of any URL that points to a JSON document, as in ours.",
      "createdAt": "2024-06-07T00:00:27Z",
      "updatedAt": "2024-06-07T00:00:27Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOL_Xevs6LkZBk",
      "title": "Add property to oauth-authorization-server to indicate client_id as URIs is supported",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/6",
      "state": "CLOSED",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently there is no way of knowing \"does this target IdP / AS support client_id's as URIs?\"\r\n\r\nWhich prevents applications from downgrading nicely, instead they'd issue the redirect and the user would be met with \"No such application exists for client_id\" type error.\r\n\r\ni'd suggest we add an extension to RFC8414's metadata document that helps indicate if client_ids as URIs is supported (could this be limited by confidentiality?)",
      "createdAt": "2024-06-08T09:36:02Z",
      "updatedAt": "2024-07-02T20:58:58Z",
      "closedAt": "2024-07-02T20:58:58Z",
      "comments": []
    },
    {
      "number": 7,
      "id": "I_kwDOL_Xevs6ML7vn",
      "title": "Exclude `client_secret_*` values from `token_endpoint_auth_method`",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/7",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "We should prohibit any `client_secret_*` values in the `token_endpoint_auth_method` for client metadata. \r\n\r\nhttps://www.rfc-editor.org/rfc/rfc7591#section-2",
      "createdAt": "2024-06-13T19:49:22Z",
      "updatedAt": "2024-07-02T21:04:33Z",
      "closedAt": "2024-07-02T21:04:33Z",
      "comments": [
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "that's what Solid OIDC does by mandating that `token_endpoint_auth_method` must be `none` \u2014 are there any other `token_endpoint_auth_method`s that exist besides those for client credentials?",
          "createdAt": "2024-06-13T20:30:36Z",
          "updatedAt": "2024-06-13T20:30:36Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "body": "Yes, RFC7523 defines a [JWT profile for client authentication](https://www.rfc-editor.org/rfc/rfc7523#section-2.2), commonly referred to as `private_key_jwt`. I already have [a note in the draft](https://drafts.aaronpk.com/draft-parecki-oauth-client-id-metadata-document/draft-parecki-oauth-client-id-metadata-document.html#name-public-vs-confidential-clie) about using this, but probably need to change that section header. \r\n\r\nThere's also [RFC8705 Mutual TLS](https://datatracker.ietf.org/doc/html/rfc8705), but I would not recommend that for this scenario.\r\n\r\nThe registry of token endpoint authentication methods is here: https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml#token-endpoint-auth-method",
          "createdAt": "2024-06-13T20:42:47Z",
          "updatedAt": "2024-06-13T20:44:45Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOL_Xevs6ML_XS",
      "title": "Expand public/confidential client considerations",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/8",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "While this draft doesn't change anything about public/confidential client considerations, it might still be helpful to include pointers to other OAuth specs that discuss some considerations such as limiting the refresh token lifetime and prompting the user for consent more frequently.",
      "createdAt": "2024-06-13T19:59:16Z",
      "updatedAt": "2024-06-13T19:59:16Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 9,
      "id": "I_kwDOL_Xevs6MMAsX",
      "title": "Add a recommendation to set a max size for the expected HTTP response when fetching client metadata",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/9",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-06-13T20:02:59Z",
      "updatedAt": "2024-07-08T16:12:20Z",
      "closedAt": "2024-07-08T16:12:20Z",
      "comments": []
    },
    {
      "number": 10,
      "id": "I_kwDOL_Xevs6MMGh2",
      "title": "Consider requiring that the `client_uri` is a prefix of the `client_id`",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/10",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The `client_uri` value is meant to point to a web page about the client. The `client_id` is the JSON metadata. So it would be reasonable for someone to implement this with values such as:\r\n\r\n```json\r\n{\r\n  \"client_id\": \"https://example.com/metadata.json\",\r\n  \"client_uri\": \"https://example.com/\"\r\n}\r\n```\r\n\r\nRequiring that the `client_uri` is a prefix means we can recommend displaying that whole value to the user, rather than only the hostname (more risky in shared domain situations) or the full `client_id` (more noisy with the potential for long strings that might scare the user)",
      "createdAt": "2024-06-13T20:19:06Z",
      "updatedAt": "2024-07-05T20:02:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This would complicate something like a development client_id metadata document provider, which would hinder developer experience getting started with using client_id metadata documents. See also #12 ",
          "createdAt": "2024-07-05T15:35:12Z",
          "updatedAt": "2024-07-05T15:35:12Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "Regarding #12, if we did have a \"metadata as a service\", think it would be reasonable to enforce that the `client_uri` be on the same origin/prefix. We don't want to hinder DX too much, but enforcing a prefix would push devs to publish their own metadata, which is desirable.",
          "createdAt": "2024-07-05T16:59:35Z",
          "updatedAt": "2024-07-05T16:59:35Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@matthieusieben I think it could only be a \"SHOULD\" and not a \"MUST\" at best. So:\r\n\r\n> `client_uri` SHOULD be a prefix of `client_id`\r\n\r\nUnless the \"client metadata document as a service\" server has some way of generating a page for `client_uri`? Or we make it a MUST but allow for omission of the `client_uri`?",
          "createdAt": "2024-07-05T18:57:35Z",
          "updatedAt": "2024-07-05T18:57:35Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There's also language in the [dynamic client registration RFC](https://www.rfc-editor.org/rfc/rfc7591.html) about `client_uri`, `tos_uri`, `policy_uri` and `logo_uri`:\r\n\r\n> In a situation where the authorization server is supporting open client registration, it must be extremely careful with any URL provided by the client that will be displayed to the user (e.g., \"logo_uri\", \"tos_uri\", \"client_uri\", and \"policy_uri\").  For instance, a rogue client could specify a registration request with a reference to a drive-by download in the \"policy_uri\", enticing the user to click on it during the authorization.  The authorization server SHOULD check to see if the \"logo_uri\", \"tos_uri\", \"client_uri\", and \"policy_uri\" have the same host and scheme as the those defined in the array of \"redirect_uris\" and that all of these URIs resolve to valid web pages.  Since these URI values that are intended to be displayed to the user at the authorization page, the authorization server SHOULD protect the user from malicious content hosted at the URLs where possible.  For instance, before presenting the URLs to the user at the authorization page, the authorization server could download the content hosted at the URLs, check the content against a malware scanner and blacklist filter, determine whether or not there is mixed secure and non-secure content at the URL, and other possible server-side mitigations.  Note that the content in these URLs can change at any time and the authorization server cannot provide complete confidence in the safety of the URLs, but these practices could help.  To further mitigate this kind of threat, the authorization server can also warn the user that the URL links have been provided by a third party, should be treated with caution, and are not hosted by the authorization server itself.  For instance, instead of providing the links directly in an HTML anchor, the authorization server can direct the user to an interstitial warning page before allowing the user to continue to the target URL.\r\n\r\nAs client metadata document support is effectively open client registration, perhaps we need a reminder of this under the security considerations?",
          "createdAt": "2024-07-05T19:00:49Z",
          "updatedAt": "2024-07-05T19:01:47Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "Since the user comes from the client origin (can be checked through the `referer` header), and will navigate back to that same origin (redirect uri, tos, policy, etc), the oauth provider does not put the user in a position of risk, even if it does not scan the various uris against potential attacks, by simply enforcing a same origin policy on all the uris. Enforcing a same prefix policy allows to better yet protect users against different clients that would be hosted on some shared CDN (think Google buckets).\n\n\nIn our implementation, we do enforce a same prefix policy for that reason.\n\nIn the case of \"loopback clients\" (clients that do not host their own metadata document, we might need to come up with a name for those), we do not allow, or show, *any* uri, logo or name (besides `127.0.0.1` redirect uris). Even with clients that do expose their own metadata document, we keep an allowlist to determine if the logo can be shown.\n\nI strongly believe that:\n- the spec should require (MUST) that the various uris be on the same origin.\n- the spec should suggest (SHOULD) that the various uris be on the same prefix\n- the spec should require (MUST) not to display the logo without manual approval\n- the spec should suggest (SHOULD) display a warning in case of non allow listed clients (\"This client pretends to be X, but make sure that the <client_origin> is indeed owned by X before you continue\")\n- the spec should suggest (SHOULD) to add additional security measures for non allow listed clients (no SSO, refresh tokens limited to short period, etc)\n- any \"metadata document as a service\" should not allow using arbitrary/unverified origins in client uris. In particular it should not (MUST NOT) bypass the same origin policy by redirecting the user to an arbitrary uri (this should be more easy to enforce by the auth server than performing a malware scan)\n- \"loopback clients\" (client uri using `http://localhost`, or any other non HTTPS uri) offer a great way for authorization servers to detect clients marking themselves as potentially vulnerable to attacks (e.g. two apps running on the same computer, the second trying to impersonate the first by using the same metadata document)\n- \"loopback clients\" also allow each auth server to provide their own default in the metadata document (though this might be problematic for interoperability)\n\n\nFor all these reasons, I think that a same prefix policy, and an indentifiable \"loopback client\" uri scheme should really be specced.",
          "createdAt": "2024-07-05T20:02:21Z",
          "updatedAt": "2024-07-05T20:02:21Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOL_Xevs6MMHoW",
      "title": "What should the AS do when it notices a client has changed its keys",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/11",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "For a client that has a registered JWKS, what should the AS do (if anything), when it notices the keys changed? Keys could change for multiple reasons:\r\n\r\n* The client is proactively rotating its keys\r\n* A client key was compromised\r\n",
      "createdAt": "2024-06-13T20:22:14Z",
      "updatedAt": "2024-06-13T20:22:14Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 12,
      "id": "I_kwDOL_Xevs6OXKPl",
      "title": "Support for localhost & non-HTTPS URIs for development purposes?",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/12",
      "state": "OPEN",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We've currently a restriction for `client_id` URIs that they MUST be https scheme. \r\n\r\nIn development environments where all software is running on localhost, we should probably provide an exception to that rule, given the issues that can be faced (self-signed certificates, custom root certificates, etc) with settings up HTTPS in development.",
      "createdAt": "2024-07-03T11:53:42Z",
      "updatedAt": "2024-08-24T21:41:09Z",
      "closedAt": null,
      "comments": [
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "At Bluesky, we actually have another use case in mind:\r\n\r\nAllow a dev that does not own/deployed a publicly available client metadata on the internet, to use a \"loopback client\" with a *production* server. In this case, what we do is we hard code the metadata in the authorization server, using query strings to allow customizing it.\r\n\r\ne.g. `http://localhost/?client_name=My%20app&redirect_uris=http%3A%2F%2F127.0.0.1%2Fcb` would be resolved by the authorization server into:\r\n\r\n```json\r\n{\r\n  \"client_id\": \"http://localhost/?client_name=My%20app&redirect_uris=http%3A%2F%2F127.0.0.1%2Fcb\",\r\n  \"client_name\": \"My app\",\r\n  \"redirect_uris\": [\"http://127.0.0.1/cb\"],\r\n  \"grant_types\": [\"authorization_code\", \"implicit\", \"refresh_token\"],\r\n  \"scope\": \"openid profile offline_access\",\r\n  \"token_endpoint_auth_method\": \"none\",\r\n  \"application_type\": \"native\",\r\n  \"dpop_bound_access_tokens\": true,\r\n}\r\n```\r\n\r\nNote that in this case, the authorization server adds other restrictions to the client, such as forbidding `prompt=none`, reducing the validity of tokens, not displaying images & links, etc. The authorization page basically reads \"A program on your device wants to get credentials for your account\".\r\n\r\nThis is our exact implementation:\r\nhttps://github.com/bluesky-social/atproto/blob/main/packages/oauth/oauth-types/src/atproto-loopback-client-metadata.ts",
          "createdAt": "2024-07-05T07:42:17Z",
          "updatedAt": "2024-07-05T07:48:58Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@matthieusieben the way we did this at Inrupt for working on Solid apps was to host a client_id at a temporary publicly accessible URL.\r\n\r\nThe other option is using something that exposes your localhost server to the public internet (which I'd not really recommend)\r\n\r\nThe reason for this is that the Authorization Server cannot access a localhost URL (without requesting to itself), so the URL of the client_id must resolve to a publicly accessible resource ",
          "createdAt": "2024-07-05T10:20:52Z",
          "updatedAt": "2024-07-05T10:20:52Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "We know about these solutions. And we also agree that this is what devs should ideally do.\r\n\r\nHowever, we believe it is critical for our business to make it as easy as possible for 3rd party devs to integrate with our systems, which is why we chose this approach. This is particularly important because we decided to adopt the current BCP, which impose a bunch of stuff (DPoP, PKCe, etc) that make OAuth client particularly difficult to implement. Having to expose a json file on the web is arguably quite simple, but we really want to cut any corner we can here.\r\n\r\nFor this reason, we:\r\n1) Do require Server Side Request Forgery protection to be in place on the OAuth Provider\r\n2) Add an exception for `localhost` to be interpreted as described\r\n\r\nI realize now that there is another solution that we did not envision; that is to offer a \"client metadata as a service\" endpoint that would use query params to build the client metadata.\r\n\r\nI guess that the use of the `localhost` hostname makes it clear to the authorization server that it is a particular type of client, and that additional restrictions should be applied.",
          "createdAt": "2024-07-05T13:06:08Z",
          "updatedAt": "2024-07-05T13:18:57Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I realize now that there is another solution that we did not envision; that is to offer a \"client metadata as a service\" endpoint that would use query params to build the client metadata\r\n\r\nThis was something that the dev tools team I was on floated as an idea, but we went with writing a generator / validator as a project for @laurin-w \u2014 unfortunately product at inrupt killed the project after it was built.\r\n\r\nIf you do support a client_id metadata documents as a service system, I'd recommend limiting it only to localhost & private IP addresses, as to make it a development-only service, such that it can't compromise production systems.",
          "createdAt": "2024-07-05T14:34:09Z",
          "updatedAt": "2024-07-05T14:34:09Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "NONE",
          "body": "FYI: At Hell\u014d https://console.hello.coop  we separate development redirect URIs from production redirect URIs. We only allow developers and testers that are registered with the team to use development redirect URIs. We then enable localhost and 127.0.0.1 by default on app creation to simplify getting up and running. \r\n\r\nThis simplifies development without the security concerns of a deployment that uses localhost. ",
          "createdAt": "2024-07-08T17:55:57Z",
          "updatedAt": "2024-07-08T17:55:57Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@dickhardt so you've two clients? one for development and one for production usage? This seems fine to me. Another approach I've seen pretty commonly is to just run a development AS and a production AS, and have laxer requirements on the former.\r\n\r\nHowever, I don't think the `client_id` URI can be a non-public URI, since the AS SHOULD request the document at this location or fail the authorization request; perhaps it's worth making this a MUST? i.e., MUST request the document, unless it has a cached copy with respect to cache-control HTTP headers.",
          "createdAt": "2024-07-08T18:40:01Z",
          "updatedAt": "2024-07-08T18:40:01Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "NONE",
          "body": "Just one client. If the provided redirect_uri is not in the list of production redirect_uris, then I check if it is a develop redirect_uri and if the user is part of the team. This is when I would allow localhost development flows. Here is a screenshot of our console page.\r\n\r\n![image](https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/assets/688982/3dfb394c-d3ec-4bf0-9c93-b7b87ae4bc4b)\r\n\r\nTo support localhost, perhaps you have to be a registered developer at the AS?  \r\n\r\nI don't think I have all the context of the use cases everyone else involved is wanting to solve. It does seem like there could be different requirements for developers vs users. \r\n\r\nIt seems one of the requirements is to someone can deploy software or use a service that has their own metadata and their own client_id without having to register their app ahead of time. The question is can they do that on localhost.\r\n",
          "createdAt": "2024-07-08T19:07:40Z",
          "updatedAt": "2024-07-08T19:07:40Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "Another concern in the case of `http://localhost` clients is the ability to declare the scopes that the client will actually request.\r\nThere are basically two approaches here:\r\n- either define no scope in the generated client metadata and let the server decide a auth time what scopes are actually granted\r\n- add a query string to the client id that describes the scope that the client would want to have (similar to the redirect_uris)\r\nWe chose to do the former.",
          "createdAt": "2024-08-23T17:37:01Z",
          "updatedAt": "2024-08-23T17:37:01Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "The drawback of the approach we decided to adopt is that is it quite counter intuitive with what you would expect the server to do with \"regular\" accessible client metadata documents. In the case a metadata document is actually available, we do require that document to list all the scopes that may be requested during an auth flow, and will return an error if more scopes are requested at auth time.",
          "createdAt": "2024-08-23T17:39:38Z",
          "updatedAt": "2024-08-23T17:39:38Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the direction I'm most leaning towards here is having a service hosted for localhost & development usage, I'm chatting with Fastly about if they could host such.",
          "createdAt": "2024-08-23T18:26:29Z",
          "updatedAt": "2024-08-23T18:26:29Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "NONE",
          "body": "A feature of localhost dev is that it works when offline ",
          "createdAt": "2024-08-23T20:43:37Z",
          "updatedAt": "2024-08-23T20:43:37Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right, but for this internet draft, it's specifically about authentication against decentralised services.\r\n\r\nSure, you could run the Authorization Server and App both on localhost and support localhost client ID metadata documents, that'd be fine, but it's very common that the Authorization Server is say, `mastodon.social` in which case you need a Client ID Metadata Document that can be fetched by `mastodon.social`\r\n\r\nSo we could add language that `localhost` URIs for Client ID Metadata Documents are supported only if the Authorization Server is also on localhost.",
          "createdAt": "2024-08-23T22:08:51Z",
          "updatedAt": "2024-08-23T22:08:51Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "NONE",
          "body": "Works for me. I was calling out potential confusion using the localhost term when using a service",
          "createdAt": "2024-08-24T19:19:03Z",
          "updatedAt": "2024-08-24T19:19:03Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, I think the current language was written such that it worked first for production environments, which tbh makes sense & in that scenario typically the AS and Client app are not operated by the same entity ",
          "createdAt": "2024-08-24T21:41:09Z",
          "updatedAt": "2024-08-24T21:41:09Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOL_Xevs6OoY5C",
      "title": "Additional TLS Requirements under Security Considerations",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/13",
      "state": "OPEN",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I was re-reading the [OAuth Authorization Server Metadata](https://datatracker.ietf.org/doc/html/rfc8414#section-6.1) RFC, and noted that it has a section on TLS Requirements. We already require HTTPS, is it worth expanding the Security Considerations to include a requirement such as \"the authorization server MUST perform a TLS/SSL server certificate check when requesting the client_id metadata document\", as is written in that specification?\r\n\r\n> Implementations MUST support TLS.  Which version(s) ought to be implemented will vary over time and depend on the widespread deployment and known security vulnerabilities at the time of implementation.  The authorization server MUST support TLS version 1.2 [RFC5246] and MAY support additional TLS mechanisms meeting its security requirements.  When using TLS, the client MUST perform a TLS/SSL server certificate check, per RFC 6125 [RFC6125]. Implementation security considerations can be found in \"Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)\" [BCP195].\r\n> \r\n> To protect against information disclosure and tampering, confidentiality protection MUST be applied using TLS with a ciphersuite that provides confidentiality and integrity protection.",
      "createdAt": "2024-07-05T17:40:55Z",
      "updatedAt": "2024-07-05T17:40:55Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 15,
      "id": "I_kwDOL_Xevs6O0BP0",
      "title": "Consider minimum set of properties to require for interoperability",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/15",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "From Dick's review on the email list: https://mailarchive.ietf.org/arch/msg/oauth/tgHv0MMU8PqyNjwsXIze3BUSn9s/\r\n\r\n> Along those lines, it may be useful to recommend which of those\r\n> properties are useful and why. For example, should I have a contact\r\n> property? I think there should be a minimum to implement so there is\r\n> interoperability -- otherwise it is hit or miss if it will work. The one\r\n> bit of client_id_metadata_document_supported will unlikely not be enough to\r\n> have a successful flow unless there is a MTI.",
      "createdAt": "2024-07-08T15:54:27Z",
      "updatedAt": "2024-07-08T15:54:28Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 16,
      "id": "I_kwDOL_Xevs6O0Bg6",
      "title": "Update property reference to IANA registry instead of DCR",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/16",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "From Dick's review: https://mailarchive.ietf.org/arch/msg/oauth/tgHv0MMU8PqyNjwsXIze3BUSn9s/\r\n\r\nhttps://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml#client-metadata",
      "createdAt": "2024-07-08T15:54:55Z",
      "updatedAt": "2024-07-08T16:18:24Z",
      "closedAt": "2024-07-08T16:18:24Z",
      "comments": []
    },
    {
      "number": 17,
      "id": "I_kwDOL_Xevs6O0Ftx",
      "title": "Add guidance for an AS that supports both registered and unregistered clients",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/17",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "From Dick's review: https://mailarchive.ietf.org/arch/msg/oauth/tgHv0MMU8PqyNjwsXIze3BUSn9s/\r\n\r\n> If an AS supports both registered, and unregistered clients, is there\r\n> any guidance or requirements on differentiating between them such as NOT\r\n> issuing other identifiers that start with 'https\"?",
      "createdAt": "2024-07-08T16:02:44Z",
      "updatedAt": "2024-07-08T16:02:44Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 18,
      "id": "I_kwDOL_Xevs6O0tHv",
      "title": "Add guidance that all URIs should be absolute, and not relative",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/18",
      "state": "OPEN",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I picked this up from @nseydoux on the Inrupt team, where the OAuth spec doesn't actually require absolute URIs for various properties like logo_uri, tos_uri, etc.\r\n\r\nRef: https://github.com/solid/solid-oidc/issues/231",
      "createdAt": "2024-07-08T17:29:45Z",
      "updatedAt": "2024-08-04T13:58:17Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Zegnat",
          "authorAssociation": "NONE",
          "body": "I was trying to figure out if there was any earlier discussion about this for [RFC 8414, Authorization server Metadata](https://www.rfc-editor.org/rfc/rfc8414). But I was not able to find anything. Feels like that would have had the same issue, but it has never come up?",
          "createdAt": "2024-08-04T13:58:16Z",
          "updatedAt": "2024-08-04T13:58:16Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "I_kwDOL_Xevs6O0tkz",
      "title": "Should data uri be allowed as logo_uri ?",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/19",
      "state": "OPEN",
      "author": "matthieusieben",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "If so, how would it impact the size limit of the whole metadata document ?",
      "createdAt": "2024-07-08T17:30:56Z",
      "updatedAt": "2024-07-12T20:07:29Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would argue that data URIs should _**not**_ be used in the metadata documents, and only `https` URIs should be used. If you did wish to support data URIs, then it would obviously increase the size limit you'd need for the whole metadata document .\r\n\r\nThat's why I went with a non-binding size limit recommendation of 5kb, because I'm aware that there can be certain scenarios where the document may be bigger, particularly with localisation of fields and such.",
          "createdAt": "2024-07-08T17:38:12Z",
          "updatedAt": "2024-07-08T17:38:25Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "Well, one advantage of data-uri is that it is easier to let the AS \"allow list\" a particular image for a particular client, and show that image to the user while authorizing.\r\n\r\nWhen an HTTPS uri is used, the actual file served could be different for the AS and USER, which could help performing phishing attacks.",
          "createdAt": "2024-07-12T18:24:37Z",
          "updatedAt": "2024-07-12T18:24:56Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "But I agree that the effect on the document size is not ideal...",
          "createdAt": "2024-07-12T18:25:31Z",
          "updatedAt": "2024-07-12T18:25:31Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> When an HTTPS uri is used, the actual file served could be different for the AS and USER, which could help performing phishing attacks.\r\n\r\nThis is true, but linking directly to a remote file on a security sensitive page would not be advisable; Instead I'd recommend AS's cache media assets such as the application logo",
          "createdAt": "2024-07-12T20:07:06Z",
          "updatedAt": "2024-07-12T20:07:29Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOL_Xevs6QeUFQ",
      "title": "Review relationship of SPICE Metadata Discovery",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/20",
      "state": "OPEN",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://www.ietf.org/archive/id/draft-steele-spice-metadata-discovery-01.html",
      "createdAt": "2024-07-22T22:23:00Z",
      "updatedAt": "2024-07-22T22:23:00Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 21,
      "id": "I_kwDOL_Xevs6QlwRk",
      "title": "Specific guidance for Mobile Application usage",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/21",
      "state": "OPEN",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "With mobile applications, unless you use application claimed https URLs and the system authentication mechanisms (I believe Apple and Google have a \"sign in with\" dialog for this now, instead of using an in-app webview), then there is potential for the `redirect_uris` to be hijacked by another application (e.g., if using a `myapp://` redirect URI scheme.\r\n\r\nI'm not sure what can be done to further mitigate this, besides DPoP and PKCE which mitigate redirect hijacking attempts.",
      "createdAt": "2024-07-23T18:10:13Z",
      "updatedAt": "2024-07-23T18:56:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "body": "Is there anything unique about this draft in regards to mobile apps? The custom scheme redirect URI issue applies to all OAuth clients, whether or not they provide their own metadata.",
          "createdAt": "2024-07-23T18:16:14Z",
          "updatedAt": "2024-07-23T18:16:14Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, I suspect there is just the same security considerations as with any custom scheme redirect URI + mobile apps, but it may not be a bad idea to reinforce that for mobile applications, you definitely want to use PKCE if using this I-D?\r\n\r\nOr maybe we just cross link to the OAuth 2.0 Security Best Current Practice document as the first section in Security Considerations, highlighting a few of the possible attack vectors to be aware of?",
          "createdAt": "2024-07-23T18:54:58Z",
          "updatedAt": "2024-07-23T18:54:58Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So like in the opening to `6. Security Considerations` explicitly listing some of the considerations to pay attention to.",
          "createdAt": "2024-07-23T18:56:01Z",
          "updatedAt": "2024-07-23T18:56:01Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "I_kwDOL_Xevs6QupaB",
      "title": "Address security contradiction of user-supplied client_id values",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/22",
      "state": "OPEN",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In OAuth 2.0 Security Best Current Practices, there's [the paragraph](https://www.ietf.org/archive/id/draft-ietf-oauth-security-topics-27.html#section-2.6-4):\r\n\r\n> Under the conditions described in [Section 4.15.1](https://www.ietf.org/archive/id/draft-ietf-oauth-security-topics-27.html#client_impersonating_countermeasures), authorization servers SHOULD NOT allow clients to influence their client_id or any claim that could cause confusion with a genuine resource owner.\r\n\r\nSince this proposal explicitly allows for user-supplied client_id values, we should probably include security guidance for such:\r\n\r\nThis is likely related to #17 \r\n",
      "createdAt": "2024-07-24T17:45:05Z",
      "updatedAt": "2024-07-24T17:45:05Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOL_Xevs5wl96g",
      "title": "Fix yaml frontmatter & prevent prettier from running",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/pull/1",
      "state": "MERGED",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Was starting to work on the draft, and was having compiling errors due to the yaml frontmatter having been incorrectly formatted by prettier (it really chokes on it), and the `url` property should've been `uri` from what I can tell.",
      "createdAt": "2024-05-26T16:03:37Z",
      "updatedAt": "2024-05-31T13:46:58Z",
      "baseRepository": "aaronpk/draft-parecki-oauth-client-id-metadata-document",
      "baseRefName": "main",
      "baseRefOid": "744111c3933074752580695018742b0811838636",
      "headRepository": "ThisIsMissEm/draft-parecki-oauth-client-id-metadata-document",
      "headRefName": "fix/prettier-and-yaml-frontmatter",
      "headRefOid": "37f38982d8ecfa22c55be6aa0766918977829544",
      "closedAt": "2024-05-31T13:46:58Z",
      "mergedAt": "2024-05-31T13:46:58Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "a9f57bdae4aa77069cb1856e49478d2a7e90f500"
      },
      "comments": [
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One thing I wasn't sure of is what the word-wrapping line length should be on this document? It'd be good to also specify this in the `.editorconfig`",
          "createdAt": "2024-05-26T16:26:19Z",
          "updatedAt": "2024-05-26T16:26:19Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 2,
      "id": "PR_kwDOL_Xevs5wmFhI",
      "title": "Suggested improvements",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/pull/2",
      "state": "MERGED",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is based on #1, but otherwise has a few language and spelling changes; Additionally:\r\n- added the section about the restriction on the `client_id` property strictly matching the client metadata document's URI\r\n- added recommendation to use a stable URL (I'm not sure if there's a spec to refer to, but it'd be bad practice to, for example, include a version number in the URL for cache busting purposes even though the contents of the document has not actually changed.\r\n- added TBD about possible verification endpoint (i.e., giving developers an easy way to verify their document is valid (or perhaps a mechanism to invalidate a previously cached document?)\r\n- added language to allow extensions to the client metadata document, and allowing it to be served as content types other than just `application/json`, e.g., `application/ld+json`\r\n- moved caching up to beneath errors, as to allow language to easily flow about requirements not to cache error responses or invalid documents.\r\n- added TBD question on the redirect URI matching and whether it is exact string matching or simple string comparison (the original language).\r\n- tried to use `client metadata document` more consistently.",
      "createdAt": "2024-05-26T17:00:57Z",
      "updatedAt": "2024-05-31T14:23:13Z",
      "baseRepository": "aaronpk/draft-parecki-oauth-client-id-metadata-document",
      "baseRefName": "main",
      "baseRefOid": "744111c3933074752580695018742b0811838636",
      "headRepository": "ThisIsMissEm/draft-parecki-oauth-client-id-metadata-document",
      "headRefName": "suggested-improvements",
      "headRefOid": "5f8f9354b8982b38f98f52a69f366264f1f1fc28",
      "closedAt": "2024-05-31T13:54:59Z",
      "mergedAt": "2024-05-31T13:54:59Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "ddd890557d6b4a6b4f4834f2a9cf0b46e4dcc6a5"
      },
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "body": "This is great, thanks. I'm going to merge it and open a few issues based on things I see here rather than hold up the merge.",
          "createdAt": "2024-05-31T13:54:56Z",
          "updatedAt": "2024-05-31T13:54:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOL_Xevs579mLh",
          "commit": {
            "abbreviatedOid": "095163b"
          },
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-26T17:01:42Z",
          "updatedAt": "2024-05-26T17:01:43Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "I moved the `MAY`s to the end, to hopefully improve clarity.",
              "createdAt": "2024-05-26T17:01:43Z",
              "updatedAt": "2024-05-26T17:01:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL_Xevs579nXw",
          "commit": {
            "abbreviatedOid": "095163b"
          },
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-26T17:04:32Z",
          "updatedAt": "2024-05-26T17:04:32Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "Would like to find some better language here, maybe referencing [Cool URIs](https://www.w3.org/Provider/Style/URI) is worthwhile?",
              "createdAt": "2024-05-26T17:04:32Z",
              "updatedAt": "2024-05-26T17:04:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL_Xevs579n3C",
          "commit": {
            "abbreviatedOid": "095163b"
          },
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-26T17:05:42Z",
          "updatedAt": "2024-05-26T17:05:42Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "This is necessary for security, as it prevents a redirect being used as a way to impersonate a client.\r\n\r\nTBD as to the algorithm for comparison: simple string comparison or exact string matching?",
              "createdAt": "2024-05-26T17:05:42Z",
              "updatedAt": "2024-05-26T17:05:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL_Xevs579ps_",
          "commit": {
            "abbreviatedOid": "095163b"
          },
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-26T17:21:34Z",
          "updatedAt": "2024-05-26T17:21:34Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "I'm not sure if I have the language here correct. But basically the idea is that authorization servers may reject specific client types or mandate that certain standard properties must be present and have a given value.",
              "createdAt": "2024-05-26T17:21:34Z",
              "updatedAt": "2024-05-26T17:21:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL_Xevs58oIdN",
          "commit": {
            "abbreviatedOid": "5f8f935"
          },
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-31T13:53:15Z",
          "updatedAt": "2024-05-31T13:53:15Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Maybe the AS should respect the HTTP cache headers that the client returns from the URL? Probably the AS should also have its own min/max cache lifetimes based on its own requirements as well.",
              "createdAt": "2024-05-31T13:53:15Z",
              "updatedAt": "2024-05-31T13:53:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL_Xevs58oeH3",
          "commit": {
            "abbreviatedOid": "5f8f935"
          },
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-31T14:23:13Z",
          "updatedAt": "2024-05-31T14:23:13Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "I was maybe thinking etags / if-unmodified-since type headers? I'm really not sure",
              "createdAt": "2024-05-31T14:23:13Z",
              "updatedAt": "2024-05-31T14:23:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOL_Xevs50jyAY",
      "title": "Feat: Maximum response size for Client Metadata Documents",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/pull/14",
      "state": "MERGED",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I did some research through other OAuth related specifications and couldn't find any similar language. I'm unsure if we should set an absolute maximum, but I think a recommendation of 5 kilobytes is probably sufficient for almost all use cases.\r\n\r\nI think typically these documents are under 1kb in size.\r\n\r\nResolves #9 ",
      "createdAt": "2024-07-05T18:29:10Z",
      "updatedAt": "2024-07-08T16:12:19Z",
      "baseRepository": "aaronpk/draft-parecki-oauth-client-id-metadata-document",
      "baseRefName": "main",
      "baseRefOid": "4acdf4744b8ab91ab77a186e2bf1c1901e365219",
      "headRepository": "ThisIsMissEm/draft-parecki-oauth-client-id-metadata-document",
      "headRefName": "feat/document-response-max-size",
      "headRefOid": "8d46176b64b72b7a2db09c487019bbef1b50ae30",
      "closedAt": "2024-07-08T16:12:19Z",
      "mergedAt": "2024-07-08T16:12:19Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "55b78eaa15323c61354812362c2b721e7a122380"
      },
      "comments": [
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One thing that may drive up the size of a client metadata document is full localisation of localisable properties in the document, given that the IANA language subtag registry includes several thousand languages: https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry\r\n\r\nSo maybe this limitation would actually be problematic, and we should just suggest something less than X megabytes, instead of kilobytes?\r\n\r\nAlthough, I don't think I've ever seen localisation used in practice.",
          "createdAt": "2024-07-05T20:17:38Z",
          "updatedAt": "2024-07-05T20:18:00Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "body": "The other option for localization is to use a different client ID per language, `https://example.com/id/en` `https://example.com/id/de` etc.\r\n\r\nThis is good enough for now , we can always change it later if we get more feedback.",
          "createdAt": "2024-07-08T16:12:16Z",
          "updatedAt": "2024-07-08T16:12:16Z"
        }
      ],
      "reviews": []
    }
  ]
}