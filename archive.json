{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-06-13T00:27:39.740184+00:00",
  "repo": "aaronpk/draft-parecki-oauth-client-id-metadata-document",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 3,
      "id": "I_kwDOL_Xevs6KwO1L",
      "title": "Caching recommendations for the metadata document",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/3",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "https://drafts.aaronpk.com/draft-parecki-oauth-client-id-metadata-document/draft-parecki-oauth-client-id-metadata-document.html#name-metadata-caching\r\n\r\nProbably makes sense to respect the HTTP cache headers from the metadata URL.\r\n\r\nThe AS should probably also have its own min/max cache lifetime policy. Not sure if we want to recommend something explicit here though since it might depend on the particular deployment.",
      "createdAt": "2024-05-31T13:56:13Z",
      "updatedAt": "2024-05-31T13:56:13Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 4,
      "id": "I_kwDOL_Xevs6KwQmr",
      "title": "need more warnings about OAuth phishing attacks",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/4",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "https://drafts.aaronpk.com/draft-parecki-oauth-client-id-metadata-document/draft-parecki-oauth-client-id-metadata-document.html#name-oauth-phishing-attacks\r\n\r\nThis section should be more explicit about the dangers of app impersonation through the metadata document.\r\n\r\nFor example, a client hosting a metadata document at `https://goooooooogle.com/metadata` could put an app name and logo icon of \"Google Docs\" in the metadata, impersonating a client that is actually `https://google.com/metadata`, potentially leading to authorizing the wrong client.\r\n\r\nWe should place a stronger recommendation around displaying the hostname of the actual `client_id` to the end user to help prevent this kind of phishing.",
      "createdAt": "2024-05-31T13:58:55Z",
      "updatedAt": "2024-06-10T11:58:54Z",
      "closedAt": null,
      "comments": [
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "Aren't there also some phishing attacks risks when allowing the redirect_uris to be on any domain? If a client does not properly encode the `state` param (like they should!), they could interpret a redirection that was initiated by an attacker as a legitimate authorization callback.",
          "createdAt": "2024-06-07T13:32:08Z",
          "updatedAt": "2024-06-07T13:32:08Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "The approach towards which I'm leaning is to require the client_uri to be the \"parent\" url of the `client_id` (the same url but without the last path segment and no query string), and require that all `redirect_uris` start with `<client_uri>/`.\r\n\r\nAlso, we don't plan on showing the `icon_uri` for unknown clients. We might put in place a mechanism to allow devs to add their clients to the allow listed clients.",
          "createdAt": "2024-06-07T14:14:20Z",
          "updatedAt": "2024-06-07T14:14:20Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The approach towards which I'm leaning is to require the client_uri to be the \"parent\" url of the `client_id` (the same url but without the last path segment and no query string), and require that all `redirect_uris` start with `<client_uri>/`.\r\n> \r\n> Also, we don't plan on showing the `icon_uri` for unknown clients. We might put in place a mechanism to allow devs to add their clients to the allow listed clients.\r\n\r\nThat breaks custom app redirect protocols",
          "createdAt": "2024-06-07T19:21:44Z",
          "updatedAt": "2024-06-07T19:21:44Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "Yeah, I'm only doing this for HTTP based uris.",
          "createdAt": "2024-06-10T07:00:15Z",
          "updatedAt": "2024-06-10T07:00:15Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This would also break HTTP cases where you want the app at `https://app.myservice.example` but the marketing/about site is `https://myservice.example`",
          "createdAt": "2024-06-10T07:23:22Z",
          "updatedAt": "2024-06-10T07:23:22Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In the case of BlueSky, you could also extend the metadata you store to include one of your bluesky DIDs, which would be used in preference over `icon_uri`, and if that client metadata document were then used against say, a mastodon server, then it'd just ignore the additional property it doesn't understand ",
          "createdAt": "2024-06-10T07:26:37Z",
          "updatedAt": "2024-06-10T07:26:37Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "I realize now that adding restrictions on the `client_uri` or `redirect_uris` is probably worthless, as these could indeed be \"valid\" (wrt to those restrictions) while performing a 3xx redirect when visited.\r\n\r\nRegarding the icon, I am not sure how using an account's profile picture (through its DID) would allow avoiding impersonation of well established companies.",
          "createdAt": "2024-06-10T09:12:14Z",
          "updatedAt": "2024-06-10T09:12:14Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It wouldn't necessarily prevent, but you'd have an on-platform identity linked which could then help with moderation ",
          "createdAt": "2024-06-10T11:58:53Z",
          "updatedAt": "2024-06-10T11:58:53Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOL_Xevs6Lb2P_",
      "title": "Compare & contrast with draft-looker-oauth-client-discovery",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/5",
      "state": "OPEN",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://www.ietf.org/archive/id/draft-looker-oauth-client-discovery-01.html\r\n\r\nThese a similar, but that I-D uses bare hostnames with a well-known path, instead of any URL that points to a JSON document, as in ours.",
      "createdAt": "2024-06-07T00:00:27Z",
      "updatedAt": "2024-06-07T00:00:27Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOL_Xevs6LkZBk",
      "title": "Add property to oauth-authorization-server to indicate client_id as URIs is supported",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/6",
      "state": "OPEN",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently there is no way of knowing \"does this target IdP / AS support client_id's as URIs?\"\r\n\r\nWhich prevents applications from downgrading nicely, instead they'd issue the redirect and the user would be met with \"No such application exists for client_id\" type error.\r\n\r\ni'd suggest we add an extension to RFC8414's metadata document that helps indicate if client_ids as URIs is supported (could this be limited by confidentiality?)",
      "createdAt": "2024-06-08T09:36:02Z",
      "updatedAt": "2024-06-08T09:36:36Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOL_Xevs5wl96g",
      "title": "Fix yaml frontmatter & prevent prettier from running",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/pull/1",
      "state": "MERGED",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Was starting to work on the draft, and was having compiling errors due to the yaml frontmatter having been incorrectly formatted by prettier (it really chokes on it), and the `url` property should've been `uri` from what I can tell.",
      "createdAt": "2024-05-26T16:03:37Z",
      "updatedAt": "2024-05-31T13:46:58Z",
      "baseRepository": "aaronpk/draft-parecki-oauth-client-id-metadata-document",
      "baseRefName": "main",
      "baseRefOid": "744111c3933074752580695018742b0811838636",
      "headRepository": "ThisIsMissEm/draft-parecki-oauth-client-id-metadata-document",
      "headRefName": "fix/prettier-and-yaml-frontmatter",
      "headRefOid": "37f38982d8ecfa22c55be6aa0766918977829544",
      "closedAt": "2024-05-31T13:46:58Z",
      "mergedAt": "2024-05-31T13:46:58Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "a9f57bdae4aa77069cb1856e49478d2a7e90f500"
      },
      "comments": [
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One thing I wasn't sure of is what the word-wrapping line length should be on this document? It'd be good to also specify this in the `.editorconfig`",
          "createdAt": "2024-05-26T16:26:19Z",
          "updatedAt": "2024-05-26T16:26:19Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 2,
      "id": "PR_kwDOL_Xevs5wmFhI",
      "title": "Suggested improvements",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/pull/2",
      "state": "MERGED",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is based on #1, but otherwise has a few language and spelling changes; Additionally:\r\n- added the section about the restriction on the `client_id` property strictly matching the client metadata document's URI\r\n- added recommendation to use a stable URL (I'm not sure if there's a spec to refer to, but it'd be bad practice to, for example, include a version number in the URL for cache busting purposes even though the contents of the document has not actually changed.\r\n- added TBD about possible verification endpoint (i.e., giving developers an easy way to verify their document is valid (or perhaps a mechanism to invalidate a previously cached document?)\r\n- added language to allow extensions to the client metadata document, and allowing it to be served as content types other than just `application/json`, e.g., `application/ld+json`\r\n- moved caching up to beneath errors, as to allow language to easily flow about requirements not to cache error responses or invalid documents.\r\n- added TBD question on the redirect URI matching and whether it is exact string matching or simple string comparison (the original language).\r\n- tried to use `client metadata document` more consistently.",
      "createdAt": "2024-05-26T17:00:57Z",
      "updatedAt": "2024-05-31T14:23:13Z",
      "baseRepository": "aaronpk/draft-parecki-oauth-client-id-metadata-document",
      "baseRefName": "main",
      "baseRefOid": "744111c3933074752580695018742b0811838636",
      "headRepository": "ThisIsMissEm/draft-parecki-oauth-client-id-metadata-document",
      "headRefName": "suggested-improvements",
      "headRefOid": "5f8f9354b8982b38f98f52a69f366264f1f1fc28",
      "closedAt": "2024-05-31T13:54:59Z",
      "mergedAt": "2024-05-31T13:54:59Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "ddd890557d6b4a6b4f4834f2a9cf0b46e4dcc6a5"
      },
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "body": "This is great, thanks. I'm going to merge it and open a few issues based on things I see here rather than hold up the merge.",
          "createdAt": "2024-05-31T13:54:56Z",
          "updatedAt": "2024-05-31T13:54:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOL_Xevs579mLh",
          "commit": {
            "abbreviatedOid": "095163b"
          },
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-26T17:01:42Z",
          "updatedAt": "2024-05-26T17:01:43Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "I moved the `MAY`s to the end, to hopefully improve clarity.",
              "createdAt": "2024-05-26T17:01:43Z",
              "updatedAt": "2024-05-26T17:01:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL_Xevs579nXw",
          "commit": {
            "abbreviatedOid": "095163b"
          },
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-26T17:04:32Z",
          "updatedAt": "2024-05-26T17:04:32Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "Would like to find some better language here, maybe referencing [Cool URIs](https://www.w3.org/Provider/Style/URI) is worthwhile?",
              "createdAt": "2024-05-26T17:04:32Z",
              "updatedAt": "2024-05-26T17:04:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL_Xevs579n3C",
          "commit": {
            "abbreviatedOid": "095163b"
          },
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-26T17:05:42Z",
          "updatedAt": "2024-05-26T17:05:42Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "This is necessary for security, as it prevents a redirect being used as a way to impersonate a client.\r\n\r\nTBD as to the algorithm for comparison: simple string comparison or exact string matching?",
              "createdAt": "2024-05-26T17:05:42Z",
              "updatedAt": "2024-05-26T17:05:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL_Xevs579ps_",
          "commit": {
            "abbreviatedOid": "095163b"
          },
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-26T17:21:34Z",
          "updatedAt": "2024-05-26T17:21:34Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "I'm not sure if I have the language here correct. But basically the idea is that authorization servers may reject specific client types or mandate that certain standard properties must be present and have a given value.",
              "createdAt": "2024-05-26T17:21:34Z",
              "updatedAt": "2024-05-26T17:21:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL_Xevs58oIdN",
          "commit": {
            "abbreviatedOid": "5f8f935"
          },
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-31T13:53:15Z",
          "updatedAt": "2024-05-31T13:53:15Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Maybe the AS should respect the HTTP cache headers that the client returns from the URL? Probably the AS should also have its own min/max cache lifetimes based on its own requirements as well.",
              "createdAt": "2024-05-31T13:53:15Z",
              "updatedAt": "2024-05-31T13:53:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL_Xevs58oeH3",
          "commit": {
            "abbreviatedOid": "5f8f935"
          },
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-31T14:23:13Z",
          "updatedAt": "2024-05-31T14:23:13Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "I was maybe thinking etags / if-unmodified-since type headers? I'm really not sure",
              "createdAt": "2024-05-31T14:23:13Z",
              "updatedAt": "2024-05-31T14:23:13Z"
            }
          ]
        }
      ]
    }
  ]
}