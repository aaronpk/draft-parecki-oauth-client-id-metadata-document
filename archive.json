{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-01-26T00:34:21.953162+00:00",
  "repo": "aaronpk/draft-parecki-oauth-client-id-metadata-document",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 3,
      "id": "I_kwDOL_Xevs6KwO1L",
      "title": "Caching recommendations for the metadata document",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/3",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "https://drafts.aaronpk.com/draft-parecki-oauth-client-id-metadata-document/draft-parecki-oauth-client-id-metadata-document.html#name-metadata-caching\r\n\r\nProbably makes sense to respect the HTTP cache headers from the metadata URL.\r\n\r\nThe AS should probably also have its own min/max cache lifetime policy. Not sure if we want to recommend something explicit here though since it might depend on the particular deployment.",
      "createdAt": "2024-05-31T13:56:13Z",
      "updatedAt": "2024-05-31T13:56:13Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 4,
      "id": "I_kwDOL_Xevs6KwQmr",
      "title": "need more warnings about OAuth phishing attacks",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/4",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "https://drafts.aaronpk.com/draft-parecki-oauth-client-id-metadata-document/draft-parecki-oauth-client-id-metadata-document.html#name-oauth-phishing-attacks\r\n\r\nThis section should be more explicit about the dangers of app impersonation through the metadata document.\r\n\r\nFor example, a client hosting a metadata document at `https://goooooooogle.com/metadata` could put an app name and logo icon of \"Google Docs\" in the metadata, impersonating a client that is actually `https://google.com/metadata`, potentially leading to authorizing the wrong client.\r\n\r\nWe should place a stronger recommendation around displaying the hostname of the actual `client_id` to the end user to help prevent this kind of phishing.",
      "createdAt": "2024-05-31T13:58:55Z",
      "updatedAt": "2024-06-10T11:58:54Z",
      "closedAt": null,
      "comments": [
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "Aren't there also some phishing attacks risks when allowing the redirect_uris to be on any domain? If a client does not properly encode the `state` param (like they should!), they could interpret a redirection that was initiated by an attacker as a legitimate authorization callback.",
          "createdAt": "2024-06-07T13:32:08Z",
          "updatedAt": "2024-06-07T13:32:08Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "The approach towards which I'm leaning is to require the client_uri to be the \"parent\" url of the `client_id` (the same url but without the last path segment and no query string), and require that all `redirect_uris` start with `<client_uri>/`.\r\n\r\nAlso, we don't plan on showing the `icon_uri` for unknown clients. We might put in place a mechanism to allow devs to add their clients to the allow listed clients.",
          "createdAt": "2024-06-07T14:14:20Z",
          "updatedAt": "2024-06-07T14:14:20Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The approach towards which I'm leaning is to require the client_uri to be the \"parent\" url of the `client_id` (the same url but without the last path segment and no query string), and require that all `redirect_uris` start with `<client_uri>/`.\r\n> \r\n> Also, we don't plan on showing the `icon_uri` for unknown clients. We might put in place a mechanism to allow devs to add their clients to the allow listed clients.\r\n\r\nThat breaks custom app redirect protocols",
          "createdAt": "2024-06-07T19:21:44Z",
          "updatedAt": "2024-06-07T19:21:44Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "Yeah, I'm only doing this for HTTP based uris.",
          "createdAt": "2024-06-10T07:00:15Z",
          "updatedAt": "2024-06-10T07:00:15Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This would also break HTTP cases where you want the app at `https://app.myservice.example` but the marketing/about site is `https://myservice.example`",
          "createdAt": "2024-06-10T07:23:22Z",
          "updatedAt": "2024-06-10T07:23:22Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In the case of BlueSky, you could also extend the metadata you store to include one of your bluesky DIDs, which would be used in preference over `icon_uri`, and if that client metadata document were then used against say, a mastodon server, then it'd just ignore the additional property it doesn't understand ",
          "createdAt": "2024-06-10T07:26:37Z",
          "updatedAt": "2024-06-10T07:26:37Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "I realize now that adding restrictions on the `client_uri` or `redirect_uris` is probably worthless, as these could indeed be \"valid\" (wrt to those restrictions) while performing a 3xx redirect when visited.\r\n\r\nRegarding the icon, I am not sure how using an account's profile picture (through its DID) would allow avoiding impersonation of well established companies.",
          "createdAt": "2024-06-10T09:12:14Z",
          "updatedAt": "2024-06-10T09:12:14Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It wouldn't necessarily prevent, but you'd have an on-platform identity linked which could then help with moderation ",
          "createdAt": "2024-06-10T11:58:53Z",
          "updatedAt": "2024-06-10T11:58:53Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOL_Xevs6Lb2P_",
      "title": "Compare & contrast with draft-looker-oauth-client-discovery",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/5",
      "state": "OPEN",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://www.ietf.org/archive/id/draft-looker-oauth-client-discovery-01.html\r\n\r\nThese a similar, but that I-D uses bare hostnames with a well-known path, instead of any URL that points to a JSON document, as in ours.",
      "createdAt": "2024-06-07T00:00:27Z",
      "updatedAt": "2024-06-07T00:00:27Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOL_Xevs6LkZBk",
      "title": "Add property to oauth-authorization-server to indicate client_id as URIs is supported",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/6",
      "state": "CLOSED",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently there is no way of knowing \"does this target IdP / AS support client_id's as URIs?\"\r\n\r\nWhich prevents applications from downgrading nicely, instead they'd issue the redirect and the user would be met with \"No such application exists for client_id\" type error.\r\n\r\ni'd suggest we add an extension to RFC8414's metadata document that helps indicate if client_ids as URIs is supported (could this be limited by confidentiality?)",
      "createdAt": "2024-06-08T09:36:02Z",
      "updatedAt": "2024-07-02T20:58:58Z",
      "closedAt": "2024-07-02T20:58:58Z",
      "comments": []
    },
    {
      "number": 7,
      "id": "I_kwDOL_Xevs6ML7vn",
      "title": "Exclude `client_secret_*` values from `token_endpoint_auth_method`",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/7",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "We should prohibit any `client_secret_*` values in the `token_endpoint_auth_method` for client metadata. \r\n\r\nhttps://www.rfc-editor.org/rfc/rfc7591#section-2",
      "createdAt": "2024-06-13T19:49:22Z",
      "updatedAt": "2024-07-02T21:04:33Z",
      "closedAt": "2024-07-02T21:04:33Z",
      "comments": [
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "that's what Solid OIDC does by mandating that `token_endpoint_auth_method` must be `none` \u2014 are there any other `token_endpoint_auth_method`s that exist besides those for client credentials?",
          "createdAt": "2024-06-13T20:30:36Z",
          "updatedAt": "2024-06-13T20:30:36Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "body": "Yes, RFC7523 defines a [JWT profile for client authentication](https://www.rfc-editor.org/rfc/rfc7523#section-2.2), commonly referred to as `private_key_jwt`. I already have [a note in the draft](https://drafts.aaronpk.com/draft-parecki-oauth-client-id-metadata-document/draft-parecki-oauth-client-id-metadata-document.html#name-public-vs-confidential-clie) about using this, but probably need to change that section header. \r\n\r\nThere's also [RFC8705 Mutual TLS](https://datatracker.ietf.org/doc/html/rfc8705), but I would not recommend that for this scenario.\r\n\r\nThe registry of token endpoint authentication methods is here: https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml#token-endpoint-auth-method",
          "createdAt": "2024-06-13T20:42:47Z",
          "updatedAt": "2024-06-13T20:44:45Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOL_Xevs6ML_XS",
      "title": "Expand public/confidential client considerations",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/8",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "While this draft doesn't change anything about public/confidential client considerations, it might still be helpful to include pointers to other OAuth specs that discuss some considerations such as limiting the refresh token lifetime and prompting the user for consent more frequently.",
      "createdAt": "2024-06-13T19:59:16Z",
      "updatedAt": "2024-06-13T19:59:16Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 9,
      "id": "I_kwDOL_Xevs6MMAsX",
      "title": "Add a recommendation to set a max size for the expected HTTP response when fetching client metadata",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/9",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-06-13T20:02:59Z",
      "updatedAt": "2024-07-08T16:12:20Z",
      "closedAt": "2024-07-08T16:12:20Z",
      "comments": []
    },
    {
      "number": 10,
      "id": "I_kwDOL_Xevs6MMGh2",
      "title": "Consider requiring that the `client_uri` is a prefix of the `client_id`",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/10",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The `client_uri` value is meant to point to a web page about the client. The `client_id` is the JSON metadata. So it would be reasonable for someone to implement this with values such as:\r\n\r\n```json\r\n{\r\n  \"client_id\": \"https://example.com/metadata.json\",\r\n  \"client_uri\": \"https://example.com/\"\r\n}\r\n```\r\n\r\nRequiring that the `client_uri` is a prefix means we can recommend displaying that whole value to the user, rather than only the hostname (more risky in shared domain situations) or the full `client_id` (more noisy with the potential for long strings that might scare the user)",
      "createdAt": "2024-06-13T20:19:06Z",
      "updatedAt": "2024-07-05T20:02:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This would complicate something like a development client_id metadata document provider, which would hinder developer experience getting started with using client_id metadata documents. See also #12 ",
          "createdAt": "2024-07-05T15:35:12Z",
          "updatedAt": "2024-07-05T15:35:12Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "Regarding #12, if we did have a \"metadata as a service\", think it would be reasonable to enforce that the `client_uri` be on the same origin/prefix. We don't want to hinder DX too much, but enforcing a prefix would push devs to publish their own metadata, which is desirable.",
          "createdAt": "2024-07-05T16:59:35Z",
          "updatedAt": "2024-07-05T16:59:35Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@matthieusieben I think it could only be a \"SHOULD\" and not a \"MUST\" at best. So:\r\n\r\n> `client_uri` SHOULD be a prefix of `client_id`\r\n\r\nUnless the \"client metadata document as a service\" server has some way of generating a page for `client_uri`? Or we make it a MUST but allow for omission of the `client_uri`?",
          "createdAt": "2024-07-05T18:57:35Z",
          "updatedAt": "2024-07-05T18:57:35Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There's also language in the [dynamic client registration RFC](https://www.rfc-editor.org/rfc/rfc7591.html) about `client_uri`, `tos_uri`, `policy_uri` and `logo_uri`:\r\n\r\n> In a situation where the authorization server is supporting open client registration, it must be extremely careful with any URL provided by the client that will be displayed to the user (e.g., \"logo_uri\", \"tos_uri\", \"client_uri\", and \"policy_uri\").  For instance, a rogue client could specify a registration request with a reference to a drive-by download in the \"policy_uri\", enticing the user to click on it during the authorization.  The authorization server SHOULD check to see if the \"logo_uri\", \"tos_uri\", \"client_uri\", and \"policy_uri\" have the same host and scheme as the those defined in the array of \"redirect_uris\" and that all of these URIs resolve to valid web pages.  Since these URI values that are intended to be displayed to the user at the authorization page, the authorization server SHOULD protect the user from malicious content hosted at the URLs where possible.  For instance, before presenting the URLs to the user at the authorization page, the authorization server could download the content hosted at the URLs, check the content against a malware scanner and blacklist filter, determine whether or not there is mixed secure and non-secure content at the URL, and other possible server-side mitigations.  Note that the content in these URLs can change at any time and the authorization server cannot provide complete confidence in the safety of the URLs, but these practices could help.  To further mitigate this kind of threat, the authorization server can also warn the user that the URL links have been provided by a third party, should be treated with caution, and are not hosted by the authorization server itself.  For instance, instead of providing the links directly in an HTML anchor, the authorization server can direct the user to an interstitial warning page before allowing the user to continue to the target URL.\r\n\r\nAs client metadata document support is effectively open client registration, perhaps we need a reminder of this under the security considerations?",
          "createdAt": "2024-07-05T19:00:49Z",
          "updatedAt": "2024-07-05T19:01:47Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "Since the user comes from the client origin (can be checked through the `referer` header), and will navigate back to that same origin (redirect uri, tos, policy, etc), the oauth provider does not put the user in a position of risk, even if it does not scan the various uris against potential attacks, by simply enforcing a same origin policy on all the uris. Enforcing a same prefix policy allows to better yet protect users against different clients that would be hosted on some shared CDN (think Google buckets).\n\n\nIn our implementation, we do enforce a same prefix policy for that reason.\n\nIn the case of \"loopback clients\" (clients that do not host their own metadata document, we might need to come up with a name for those), we do not allow, or show, *any* uri, logo or name (besides `127.0.0.1` redirect uris). Even with clients that do expose their own metadata document, we keep an allowlist to determine if the logo can be shown.\n\nI strongly believe that:\n- the spec should require (MUST) that the various uris be on the same origin.\n- the spec should suggest (SHOULD) that the various uris be on the same prefix\n- the spec should require (MUST) not to display the logo without manual approval\n- the spec should suggest (SHOULD) display a warning in case of non allow listed clients (\"This client pretends to be X, but make sure that the <client_origin> is indeed owned by X before you continue\")\n- the spec should suggest (SHOULD) to add additional security measures for non allow listed clients (no SSO, refresh tokens limited to short period, etc)\n- any \"metadata document as a service\" should not allow using arbitrary/unverified origins in client uris. In particular it should not (MUST NOT) bypass the same origin policy by redirecting the user to an arbitrary uri (this should be more easy to enforce by the auth server than performing a malware scan)\n- \"loopback clients\" (client uri using `http://localhost`, or any other non HTTPS uri) offer a great way for authorization servers to detect clients marking themselves as potentially vulnerable to attacks (e.g. two apps running on the same computer, the second trying to impersonate the first by using the same metadata document)\n- \"loopback clients\" also allow each auth server to provide their own default in the metadata document (though this might be problematic for interoperability)\n\n\nFor all these reasons, I think that a same prefix policy, and an indentifiable \"loopback client\" uri scheme should really be specced.",
          "createdAt": "2024-07-05T20:02:21Z",
          "updatedAt": "2024-07-05T20:02:21Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOL_Xevs6MMHoW",
      "title": "What should the AS do when it notices a client has changed its keys",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/11",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "For a client that has a registered JWKS, what should the AS do (if anything), when it notices the keys changed? Keys could change for multiple reasons:\r\n\r\n* The client is proactively rotating its keys\r\n* A client key was compromised\r\n",
      "createdAt": "2024-06-13T20:22:14Z",
      "updatedAt": "2024-06-13T20:22:14Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 12,
      "id": "I_kwDOL_Xevs6OXKPl",
      "title": "Support for localhost & non-HTTPS URIs for development purposes?",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/12",
      "state": "OPEN",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We've currently a restriction for `client_id` URIs that they MUST be https scheme. \r\n\r\nIn development environments where all software is running on localhost, we should probably provide an exception to that rule, given the issues that can be faced (self-signed certificates, custom root certificates, etc) with settings up HTTPS in development.",
      "createdAt": "2024-07-03T11:53:42Z",
      "updatedAt": "2024-08-24T21:41:09Z",
      "closedAt": null,
      "comments": [
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "At Bluesky, we actually have another use case in mind:\r\n\r\nAllow a dev that does not own/deployed a publicly available client metadata on the internet, to use a \"loopback client\" with a *production* server. In this case, what we do is we hard code the metadata in the authorization server, using query strings to allow customizing it.\r\n\r\ne.g. `http://localhost/?client_name=My%20app&redirect_uris=http%3A%2F%2F127.0.0.1%2Fcb` would be resolved by the authorization server into:\r\n\r\n```json\r\n{\r\n  \"client_id\": \"http://localhost/?client_name=My%20app&redirect_uris=http%3A%2F%2F127.0.0.1%2Fcb\",\r\n  \"client_name\": \"My app\",\r\n  \"redirect_uris\": [\"http://127.0.0.1/cb\"],\r\n  \"grant_types\": [\"authorization_code\", \"implicit\", \"refresh_token\"],\r\n  \"scope\": \"openid profile offline_access\",\r\n  \"token_endpoint_auth_method\": \"none\",\r\n  \"application_type\": \"native\",\r\n  \"dpop_bound_access_tokens\": true,\r\n}\r\n```\r\n\r\nNote that in this case, the authorization server adds other restrictions to the client, such as forbidding `prompt=none`, reducing the validity of tokens, not displaying images & links, etc. The authorization page basically reads \"A program on your device wants to get credentials for your account\".\r\n\r\nThis is our exact implementation:\r\nhttps://github.com/bluesky-social/atproto/blob/main/packages/oauth/oauth-types/src/atproto-loopback-client-metadata.ts",
          "createdAt": "2024-07-05T07:42:17Z",
          "updatedAt": "2024-07-05T07:48:58Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@matthieusieben the way we did this at Inrupt for working on Solid apps was to host a client_id at a temporary publicly accessible URL.\r\n\r\nThe other option is using something that exposes your localhost server to the public internet (which I'd not really recommend)\r\n\r\nThe reason for this is that the Authorization Server cannot access a localhost URL (without requesting to itself), so the URL of the client_id must resolve to a publicly accessible resource ",
          "createdAt": "2024-07-05T10:20:52Z",
          "updatedAt": "2024-07-05T10:20:52Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "We know about these solutions. And we also agree that this is what devs should ideally do.\r\n\r\nHowever, we believe it is critical for our business to make it as easy as possible for 3rd party devs to integrate with our systems, which is why we chose this approach. This is particularly important because we decided to adopt the current BCP, which impose a bunch of stuff (DPoP, PKCe, etc) that make OAuth client particularly difficult to implement. Having to expose a json file on the web is arguably quite simple, but we really want to cut any corner we can here.\r\n\r\nFor this reason, we:\r\n1) Do require Server Side Request Forgery protection to be in place on the OAuth Provider\r\n2) Add an exception for `localhost` to be interpreted as described\r\n\r\nI realize now that there is another solution that we did not envision; that is to offer a \"client metadata as a service\" endpoint that would use query params to build the client metadata.\r\n\r\nI guess that the use of the `localhost` hostname makes it clear to the authorization server that it is a particular type of client, and that additional restrictions should be applied.",
          "createdAt": "2024-07-05T13:06:08Z",
          "updatedAt": "2024-07-05T13:18:57Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I realize now that there is another solution that we did not envision; that is to offer a \"client metadata as a service\" endpoint that would use query params to build the client metadata\r\n\r\nThis was something that the dev tools team I was on floated as an idea, but we went with writing a generator / validator as a project for @laurin-w \u2014 unfortunately product at inrupt killed the project after it was built.\r\n\r\nIf you do support a client_id metadata documents as a service system, I'd recommend limiting it only to localhost & private IP addresses, as to make it a development-only service, such that it can't compromise production systems.",
          "createdAt": "2024-07-05T14:34:09Z",
          "updatedAt": "2024-07-05T14:34:09Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "NONE",
          "body": "FYI: At Hell\u014d https://console.hello.coop  we separate development redirect URIs from production redirect URIs. We only allow developers and testers that are registered with the team to use development redirect URIs. We then enable localhost and 127.0.0.1 by default on app creation to simplify getting up and running. \r\n\r\nThis simplifies development without the security concerns of a deployment that uses localhost. ",
          "createdAt": "2024-07-08T17:55:57Z",
          "updatedAt": "2024-07-08T17:55:57Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@dickhardt so you've two clients? one for development and one for production usage? This seems fine to me. Another approach I've seen pretty commonly is to just run a development AS and a production AS, and have laxer requirements on the former.\r\n\r\nHowever, I don't think the `client_id` URI can be a non-public URI, since the AS SHOULD request the document at this location or fail the authorization request; perhaps it's worth making this a MUST? i.e., MUST request the document, unless it has a cached copy with respect to cache-control HTTP headers.",
          "createdAt": "2024-07-08T18:40:01Z",
          "updatedAt": "2024-07-08T18:40:01Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "NONE",
          "body": "Just one client. If the provided redirect_uri is not in the list of production redirect_uris, then I check if it is a develop redirect_uri and if the user is part of the team. This is when I would allow localhost development flows. Here is a screenshot of our console page.\r\n\r\n![image](https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/assets/688982/3dfb394c-d3ec-4bf0-9c93-b7b87ae4bc4b)\r\n\r\nTo support localhost, perhaps you have to be a registered developer at the AS?  \r\n\r\nI don't think I have all the context of the use cases everyone else involved is wanting to solve. It does seem like there could be different requirements for developers vs users. \r\n\r\nIt seems one of the requirements is to someone can deploy software or use a service that has their own metadata and their own client_id without having to register their app ahead of time. The question is can they do that on localhost.\r\n",
          "createdAt": "2024-07-08T19:07:40Z",
          "updatedAt": "2024-07-08T19:07:40Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "Another concern in the case of `http://localhost` clients is the ability to declare the scopes that the client will actually request.\r\nThere are basically two approaches here:\r\n- either define no scope in the generated client metadata and let the server decide a auth time what scopes are actually granted\r\n- add a query string to the client id that describes the scope that the client would want to have (similar to the redirect_uris)\r\nWe chose to do the former.",
          "createdAt": "2024-08-23T17:37:01Z",
          "updatedAt": "2024-08-23T17:37:01Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "The drawback of the approach we decided to adopt is that is it quite counter intuitive with what you would expect the server to do with \"regular\" accessible client metadata documents. In the case a metadata document is actually available, we do require that document to list all the scopes that may be requested during an auth flow, and will return an error if more scopes are requested at auth time.",
          "createdAt": "2024-08-23T17:39:38Z",
          "updatedAt": "2024-08-23T17:39:38Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the direction I'm most leaning towards here is having a service hosted for localhost & development usage, I'm chatting with Fastly about if they could host such.",
          "createdAt": "2024-08-23T18:26:29Z",
          "updatedAt": "2024-08-23T18:26:29Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "NONE",
          "body": "A feature of localhost dev is that it works when offline ",
          "createdAt": "2024-08-23T20:43:37Z",
          "updatedAt": "2024-08-23T20:43:37Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right, but for this internet draft, it's specifically about authentication against decentralised services.\r\n\r\nSure, you could run the Authorization Server and App both on localhost and support localhost client ID metadata documents, that'd be fine, but it's very common that the Authorization Server is say, `mastodon.social` in which case you need a Client ID Metadata Document that can be fetched by `mastodon.social`\r\n\r\nSo we could add language that `localhost` URIs for Client ID Metadata Documents are supported only if the Authorization Server is also on localhost.",
          "createdAt": "2024-08-23T22:08:51Z",
          "updatedAt": "2024-08-23T22:08:51Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "NONE",
          "body": "Works for me. I was calling out potential confusion using the localhost term when using a service",
          "createdAt": "2024-08-24T19:19:03Z",
          "updatedAt": "2024-08-24T19:19:03Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, I think the current language was written such that it worked first for production environments, which tbh makes sense & in that scenario typically the AS and Client app are not operated by the same entity ",
          "createdAt": "2024-08-24T21:41:09Z",
          "updatedAt": "2024-08-24T21:41:09Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOL_Xevs6OoY5C",
      "title": "Additional TLS Requirements under Security Considerations",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/13",
      "state": "OPEN",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I was re-reading the [OAuth Authorization Server Metadata](https://datatracker.ietf.org/doc/html/rfc8414#section-6.1) RFC, and noted that it has a section on TLS Requirements. We already require HTTPS, is it worth expanding the Security Considerations to include a requirement such as \"the authorization server MUST perform a TLS/SSL server certificate check when requesting the client_id metadata document\", as is written in that specification?\r\n\r\n> Implementations MUST support TLS.  Which version(s) ought to be implemented will vary over time and depend on the widespread deployment and known security vulnerabilities at the time of implementation.  The authorization server MUST support TLS version 1.2 [RFC5246] and MAY support additional TLS mechanisms meeting its security requirements.  When using TLS, the client MUST perform a TLS/SSL server certificate check, per RFC 6125 [RFC6125]. Implementation security considerations can be found in \"Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)\" [BCP195].\r\n> \r\n> To protect against information disclosure and tampering, confidentiality protection MUST be applied using TLS with a ciphersuite that provides confidentiality and integrity protection.",
      "createdAt": "2024-07-05T17:40:55Z",
      "updatedAt": "2024-07-05T17:40:55Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 15,
      "id": "I_kwDOL_Xevs6O0BP0",
      "title": "Consider minimum set of properties to require for interoperability",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/15",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "From Dick's review on the email list: https://mailarchive.ietf.org/arch/msg/oauth/tgHv0MMU8PqyNjwsXIze3BUSn9s/\r\n\r\n> Along those lines, it may be useful to recommend which of those\r\n> properties are useful and why. For example, should I have a contact\r\n> property? I think there should be a minimum to implement so there is\r\n> interoperability -- otherwise it is hit or miss if it will work. The one\r\n> bit of client_id_metadata_document_supported will unlikely not be enough to\r\n> have a successful flow unless there is a MTI.",
      "createdAt": "2024-07-08T15:54:27Z",
      "updatedAt": "2024-07-08T15:54:28Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 16,
      "id": "I_kwDOL_Xevs6O0Bg6",
      "title": "Update property reference to IANA registry instead of DCR",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/16",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "From Dick's review: https://mailarchive.ietf.org/arch/msg/oauth/tgHv0MMU8PqyNjwsXIze3BUSn9s/\r\n\r\nhttps://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml#client-metadata",
      "createdAt": "2024-07-08T15:54:55Z",
      "updatedAt": "2024-07-08T16:18:24Z",
      "closedAt": "2024-07-08T16:18:24Z",
      "comments": []
    },
    {
      "number": 17,
      "id": "I_kwDOL_Xevs6O0Ftx",
      "title": "Add guidance for an AS that supports both registered and unregistered clients",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/17",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "From Dick's review: https://mailarchive.ietf.org/arch/msg/oauth/tgHv0MMU8PqyNjwsXIze3BUSn9s/\r\n\r\n> If an AS supports both registered, and unregistered clients, is there\r\n> any guidance or requirements on differentiating between them such as NOT\r\n> issuing other identifiers that start with 'https\"?",
      "createdAt": "2024-07-08T16:02:44Z",
      "updatedAt": "2025-01-06T23:42:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this would be dealt with through Client ID Schemes as discussed today, though perhaps we just need a security consideration of \"If an Authorization Server wishes to support both generated client_id values for registered clients and client metadata documents, it should take care to ensure that the generated client_id's do not start with `https://`\"",
          "createdAt": "2025-01-06T23:42:40Z",
          "updatedAt": "2025-01-06T23:42:40Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "I_kwDOL_Xevs6O0tHv",
      "title": "Add guidance that all URIs should be absolute, and not relative",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/18",
      "state": "OPEN",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I picked this up from @nseydoux on the Inrupt team, where the OAuth spec doesn't actually require absolute URIs for various properties like logo_uri, tos_uri, etc.\r\n\r\nRef: https://github.com/solid/solid-oidc/issues/231",
      "createdAt": "2024-07-08T17:29:45Z",
      "updatedAt": "2024-08-04T13:58:17Z",
      "closedAt": null,
      "comments": [
        {
          "author": "Zegnat",
          "authorAssociation": "NONE",
          "body": "I was trying to figure out if there was any earlier discussion about this for [RFC 8414, Authorization server Metadata](https://www.rfc-editor.org/rfc/rfc8414). But I was not able to find anything. Feels like that would have had the same issue, but it has never come up?",
          "createdAt": "2024-08-04T13:58:16Z",
          "updatedAt": "2024-08-04T13:58:16Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "I_kwDOL_Xevs6O0tkz",
      "title": "Should data uri be allowed as logo_uri ?",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/19",
      "state": "OPEN",
      "author": "matthieusieben",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "If so, how would it impact the size limit of the whole metadata document ?",
      "createdAt": "2024-07-08T17:30:56Z",
      "updatedAt": "2025-01-10T00:38:55Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would argue that data URIs should _**not**_ be used in the metadata documents, and only `https` URIs should be used. If you did wish to support data URIs, then it would obviously increase the size limit you'd need for the whole metadata document .\r\n\r\nThat's why I went with a non-binding size limit recommendation of 5kb, because I'm aware that there can be certain scenarios where the document may be bigger, particularly with localisation of fields and such.",
          "createdAt": "2024-07-08T17:38:12Z",
          "updatedAt": "2024-07-08T17:38:25Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "Well, one advantage of data-uri is that it is easier to let the AS \"allow list\" a particular image for a particular client, and show that image to the user while authorizing.\r\n\r\nWhen an HTTPS uri is used, the actual file served could be different for the AS and USER, which could help performing phishing attacks.",
          "createdAt": "2024-07-12T18:24:37Z",
          "updatedAt": "2024-07-12T18:24:56Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "But I agree that the effect on the document size is not ideal...",
          "createdAt": "2024-07-12T18:25:31Z",
          "updatedAt": "2024-07-12T18:25:31Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> When an HTTPS uri is used, the actual file served could be different for the AS and USER, which could help performing phishing attacks.\r\n\r\nThis is true, but linking directly to a remote file on a security sensitive page would not be advisable; Instead I'd recommend AS's cache media assets such as the application logo",
          "createdAt": "2024-07-12T20:07:06Z",
          "updatedAt": "2024-07-12T20:07:29Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Have opened #25 ",
          "createdAt": "2025-01-06T23:38:51Z",
          "updatedAt": "2025-01-06T23:38:51Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't specifically call out data uri's in that security consideration, but more that the authorization server shouldn't just be using the `logo_uri` verbatim in their authorization pages, and instead should fetch the resource and cache it, as to serve it from a trusted domain (this would also be inline with having a narrow CSP for `image-src`)",
          "createdAt": "2025-01-06T23:40:18Z",
          "updatedAt": "2025-01-06T23:40:18Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "body": "I agree with the recommendation for the AS to cache and serve the image itself. \r\n\r\nInterestingly, the client providing a data URI and the AS outputting the string verbatim does meet the requirement of not serving 3rd party hosted images \ud83d\ude02 ",
          "createdAt": "2025-01-10T00:38:54Z",
          "updatedAt": "2025-01-10T00:38:54Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOL_Xevs6QeUFQ",
      "title": "Review relationship of SPICE Metadata Discovery",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/20",
      "state": "OPEN",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://www.ietf.org/archive/id/draft-steele-spice-metadata-discovery-01.html",
      "createdAt": "2024-07-22T22:23:00Z",
      "updatedAt": "2024-07-22T22:23:00Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 21,
      "id": "I_kwDOL_Xevs6QlwRk",
      "title": "Specific guidance for Mobile Application usage",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/21",
      "state": "OPEN",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "With mobile applications, unless you use application claimed https URLs and the system authentication mechanisms (I believe Apple and Google have a \"sign in with\" dialog for this now, instead of using an in-app webview), then there is potential for the `redirect_uris` to be hijacked by another application (e.g., if using a `myapp://` redirect URI scheme.\r\n\r\nI'm not sure what can be done to further mitigate this, besides DPoP and PKCE which mitigate redirect hijacking attempts.",
      "createdAt": "2024-07-23T18:10:13Z",
      "updatedAt": "2024-07-23T18:56:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "body": "Is there anything unique about this draft in regards to mobile apps? The custom scheme redirect URI issue applies to all OAuth clients, whether or not they provide their own metadata.",
          "createdAt": "2024-07-23T18:16:14Z",
          "updatedAt": "2024-07-23T18:16:14Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, I suspect there is just the same security considerations as with any custom scheme redirect URI + mobile apps, but it may not be a bad idea to reinforce that for mobile applications, you definitely want to use PKCE if using this I-D?\r\n\r\nOr maybe we just cross link to the OAuth 2.0 Security Best Current Practice document as the first section in Security Considerations, highlighting a few of the possible attack vectors to be aware of?",
          "createdAt": "2024-07-23T18:54:58Z",
          "updatedAt": "2024-07-23T18:54:58Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So like in the opening to `6. Security Considerations` explicitly listing some of the considerations to pay attention to.",
          "createdAt": "2024-07-23T18:56:01Z",
          "updatedAt": "2024-07-23T18:56:01Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "I_kwDOL_Xevs6QupaB",
      "title": "Address security contradiction of user-supplied client_id values",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/22",
      "state": "OPEN",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In OAuth 2.0 Security Best Current Practices, there's [the paragraph](https://www.ietf.org/archive/id/draft-ietf-oauth-security-topics-27.html#section-2.6-4):\r\n\r\n> Under the conditions described in [Section 4.15.1](https://www.ietf.org/archive/id/draft-ietf-oauth-security-topics-27.html#client_impersonating_countermeasures), authorization servers SHOULD NOT allow clients to influence their client_id or any claim that could cause confusion with a genuine resource owner.\r\n\r\nSince this proposal explicitly allows for user-supplied client_id values, we should probably include security guidance for such:\r\n\r\nThis is likely related to #17 \r\n",
      "createdAt": "2024-07-24T17:45:05Z",
      "updatedAt": "2024-07-24T17:45:05Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 23,
      "id": "I_kwDOL_Xevs6c-6ck",
      "title": "Clarify the security implications of using query parameters in client_id to dynamically generate metadata documents",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/23",
      "state": "OPEN",
      "author": "birdhalfbaked",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "While reading the draft, it currently seems to allow broad use of query parameters in the client_id for sending information that a guides the use of metadata that should be retrieved in the flows. \r\n\r\n> **Client identifier URLs MAY contain a query string component** and MAY contain a port.\r\n> This specification places no restrictions on what URL is used as a client identifier. A short URL is RECOMMENDED, since the URL may be displayed to the end user in the authorization interface or in management interfaces. Usage of a stable URL that does not frequently change for the client is also RECOMMENDED.\r\n\r\n(emphasis mine)\r\n\r\nWe already see some implementations using this to facilitate development by passing OAuth metadata (e.g. `scope `and `redirect_uris`) such as with ATProto's use of OAuth in the [localhost exception case](https://atproto.com/specs/oauth), and as written this may mistakenly encourage the use of dynamically-generated metadata documents from user-given inputs even in non-development use cases which can undermine the mechanisms herein.\r\n\r\ne.g. `client_id: https://someurl.com?scope=scope1%20scope2` is allowed, but should be strongly discouraged outside of local development contexts.\r\n\r\nThis discouragement could fit well in the additional **Security Considerations** I am thinking. Something along the lines \"Authorization servers SHOULD reject the use of query params to dynamically generate metadata outside of development contexts where other methods of generating metadata documents are not practical.\" \r\n\r\nWording probably needs work :P Also reinforces some good ideas I've seen around setting up a service for development metadata documents like in #12 ",
      "createdAt": "2024-11-04T20:07:13Z",
      "updatedAt": "2025-01-10T22:01:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would probably say that we should discourage the use of query string arguments in the `client_id` document URL. Instead, services that allow creating a Client ID Metadata Document should instead generate a stable identifier for that document. e.g., instead of `https://client_id.example.com/client.json?scopes=read&client_name=example`, it would be better to have these registered with that service as: `https://client_id.example.com/WtzJCPeDSGs4FsKPlNy3.json` where `WtzJCPeDSGs4FsKPlNy3` identifies the record that stores the metadata.\r\n\r\nThis does make such a service stateful, rather than stateless, but has better security properties, in my opinion.\r\n\r\nI would also think it'd be an idea to introduce a new property in the **OAuth Dynamic Client Registration Metadata** IANA registry of `client_expires_at` which is the timestamp at which the entire client should be deemed no longer valid (such to allow cache purging of development clients), this is necessary as Client ID Metadata Documents don't have a client secret, therefore cannot use `client_secret_expires_at`.",
          "createdAt": "2025-01-06T22:45:42Z",
          "updatedAt": "2025-01-06T22:45:42Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "body": "Couldn't we use http cache headers to let the client indicate its intended lifetime of the document? Obvs the AS can cache or not cache as long as it wants, but this is an existing mechanism that could be used to indicate the doc lifetime. Also would be worth checking if AS metadata or RS metadata have any mention of http cache headers.",
          "createdAt": "2025-01-06T22:49:52Z",
          "updatedAt": "2025-01-06T22:49:52Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this could be reasonable, but my concern is that the client metadata document could be considered \"expired\" before the AS decides to revalidate its cache. That is, if the client metadata document cache header says \"cache me for a month\" and the AS goes \"nah, I cache things for a 6 months\", then we'll hit into issues where the AS will keep hold of a client metadata document that the provider of the document thinks is expired/no-longer valid.",
          "createdAt": "2025-01-06T23:45:30Z",
          "updatedAt": "2025-01-06T23:45:30Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "I like @birdhalfbaked 's proposal to add the following into the security considerations:\r\n\r\n> \"Authorization servers SHOULD reject the use of query params to dynamically generate metadata outside of development contexts where other methods of generating metadata documents are not practical.\"\r\n\r\nI don't think Atproto will get rid of the localhost exception just yet but I can see us adding a restriction forbidding use of query strings for non \"loopback clients\".",
          "createdAt": "2025-01-07T14:55:15Z",
          "updatedAt": "2025-01-07T14:55:15Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd recommend going the route of having a service that registers and serves documents, rather than generating them through query parameters. That way it's just a bit harder to create multiple documents to confuse just by changing URL parameters.\r\n\r\nE.g., by storing that information you can perform validation and moderation on it as necessary.\r\n\r\nThat's why I've gone the route of removing query parameters from the client metadata document URIs.",
          "createdAt": "2025-01-07T18:02:28Z",
          "updatedAt": "2025-01-07T18:03:00Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@aaronpk yeah, I think we can use the `Expires` header for this: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires\r\n\r\nPerhaps we just need particular language around this? \"A server responding to a request for a client metadata document MAY return the Expires header, indicating that the given client metadata document expires after a given time, at which point the client should be considered revoked if re-requesting the metadata document URI fails\"",
          "createdAt": "2025-01-10T17:02:32Z",
          "updatedAt": "2025-01-10T17:02:32Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Opened #29 with the above.",
          "createdAt": "2025-01-10T20:50:27Z",
          "updatedAt": "2025-01-10T20:50:27Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@matthieusieben I would say that what Bluesky is doing with its localhost client_id's is side-stepping this internet draft completely. It is its own thing entirely. This internet draft relies on the ability for the authorization server to request and validate the client_id as being a client metadata document, what you're doing isn't that.",
          "createdAt": "2025-01-10T20:51:39Z",
          "updatedAt": "2025-01-10T20:52:31Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "I think you're right. Considering them separate things makes a lot of sense.",
          "createdAt": "2025-01-10T22:01:23Z",
          "updatedAt": "2025-01-10T22:01:23Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOL_Xevs6lpP-s",
      "title": "Using `client_url` instead of `client_id` in authorize request",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/26",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "After presenting this draft at IETF 121, one concern that came up was how an AS can support both registered and unregistered clients, as well as how an AS can support clients that have different ways to retrieve metadata but might also be represented by a URL. In particular [OpenID Federation](https://openid.net/specs/openid-federation-1_0.html) also uses URLs as client IDs, so there is a potential ambiguity if an AS supports both OpenID Federation and Client ID Metadata Documents, how does it know which method to use to retrieve the client metadata given just a plain URL.\r\n\r\nThis led to the proposal of pulling out the idea of a \"client ID scheme\" from OpenID4VP into its own draft: https://datatracker.ietf.org/doc/draft-parecki-oauth-client-id-scheme/\r\n\r\nI presented this at the interim meeting this week for feedback.\r\n\r\nOne concern that was raised was that an AS might want to avoid any kind of need to parse the client ID. As an alternative, the client metadata URL could be provided in an authorization request using a new parameter `client_url` instead of `client_id`, leaving `client_id` to represent registered clients. (Note that in the example given, the AS would only support preregistered clients and client metadata document clients, but not OpenID Federation or clients using DID URLs like was mentioned in the client ID scheme doc.)\r\n\r\nSo an OAuth authorization request would look like:\r\n\r\n```\r\nhttps://authorization-server.com/authorize?response_type=code&client_url=https://client.example.com/id&scope=etc&...\r\n```\r\n\r\nI wanted to capture this issue here to get feedback on the issue. \r\n\r\n* While this would be a completely breaking change for anyone who has adopted client metadata documents today, are the benefits worth it? \r\n* Do you see yourself wanting to also support preregistered clients at some point?\r\n* Is parsing a client ID a concern for you?",
      "createdAt": "2025-01-10T01:05:32Z",
      "updatedAt": "2025-01-10T03:41:43Z",
      "closedAt": null,
      "comments": [
        {
          "author": "carrvo",
          "authorAssociation": "NONE",
          "body": "The main feature that attracted me to IndieAuth in the first place was the ability to avoid preregistration completely. The alternative is dynamic registration but that adds a fair bit of complexity, storage, and I have not seen widely adopted (For example I believe it is not by Microsoft and Google). I keep imagining a decentralized future where many to most decided to self-host their own Identity Provider (IdP).\r\n\r\nI am not sure what all the \"benefits\" spoken of are; but my biggest question is whether the change from `client_id` to `client_url` would effect its compatibility with OAuth clients who are unaware of the IndieAuth backend?",
          "createdAt": "2025-01-10T03:03:04Z",
          "updatedAt": "2025-01-10T03:03:04Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "body": "The goal is very much to avoid preregistration. Changing from `client_id` to `client_url` would mean needing to modify any OAuth client library to be usable for IndieAuth, since it would not use the `client_id` parameter anymore.",
          "createdAt": "2025-01-10T03:05:27Z",
          "updatedAt": "2025-01-10T03:05:27Z"
        },
        {
          "author": "carrvo",
          "authorAssociation": "NONE",
          "body": "Then I would unfortunately be against the change. I have just figured out how to make [mod_oauth2](https://github.com/OpenIDC/mod_oauth2) compatible with IndieAuth and this would break that (they likely would not accept any changes for this).",
          "createdAt": "2025-01-10T03:41:42Z",
          "updatedAt": "2025-01-10T03:41:42Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDOL_Xevs6lpy5f",
      "title": "Optional Scope Descriptions as Additional Property in the Client Metadata Document",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/27",
      "state": "CLOSED",
      "author": "carrvo",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As a part of the client metadata document\r\n\r\n> The client metadata document URL is a JSON document containing the metadata of the client. The client metadata values are the values defined in the OAuth Dynamic Client Registration Metadata OAuth Parameters registry https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml#client-metadata.\r\n> ...\r\n> The client metadata document MAY define additional properties in the response. The client metadata document MAY also be served with more specific content types as long as the response is JSON and conforms to application/<AS-defined>+json.\r\n\r\nIt would be valuable to non-technical users if it included an optional field that held user-friendly scope descriptions that could be shown during authentication/authorization, where only the scope is included in future tokens (that end users do not typically inspect).\r\n\r\nFitness Example:\r\n```json\r\n{\r\n    \"iss\": \"https://example.com\",\r\n    \"client_id\": \"https://example.com/fitness.json\",\r\n    \"client_uri\": \"https://example.com/fitness.html\",\r\n    \"response_types\": [\"code\"],\r\n    \"grant_types\": [\"authorization_code\"],\r\n    \"scope\": \"fitall:rd fitwe:wt\",\r\n    \"scope_descriptions\": {\r\n        \"fitall:rd\": \"access personal data attributes height, age, weight, and fitness\",\r\n        \"fitwe:wt\": \"modify personal data attribute weight\"\r\n    }\r\n}\r\n```",
      "createdAt": "2025-01-10T03:32:34Z",
      "updatedAt": "2025-01-16T00:09:12Z",
      "closedAt": "2025-01-15T22:50:39Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "body": "Scopes are defined by the authorization server, not by the client. If the client could provide this information there are a lot of potential phishing attacks possible.",
          "createdAt": "2025-01-10T03:36:48Z",
          "updatedAt": "2025-01-10T03:36:48Z"
        },
        {
          "author": "carrvo",
          "authorAssociation": "NONE",
          "body": "I don't think that I follow. The client would be requesting scopes that a resource server would understand. At least for [SelfAuth](https://github.com/Inklings-io/selfauth)+[MinToken](https://github.com/Zegnat/php-mintoken) the authorization server neither defines nor understands the scopes (except `profile` and `email`) and merely reflects the scopes approved back in the token. I welcome a correction to my understanding which is that scopes are defined and understood on a per-application basis.\r\n\r\nI also don't understand why there would be phishing attacks. The client must already request the scopes (and therefore know the scope names); and the client, after retrieving the information or performing the action against the server who defined those scopes, must have an understanding of what it is using the scopes to accomplish. With regards to an attack vector, I expect that this poses risk of HTML/script injection if the authorization server decides (completely optional) to display the values without sanitizing it. I don't see the phishing angle since this information would be used at the point of granting a client (malicious or valid) access to scopes; and to display the client-provided additional information about said scopes does not skip the user's choice to grant (and the user should be checking the client ID for malicious clients) access--access that they would potentially grant without this feature.\r\n\r\nIf it is really such a security issue I am not against closing and forgetting. This is never meant to be more than optionally user-friendly anyway.",
          "createdAt": "2025-01-15T00:30:07Z",
          "updatedAt": "2025-01-15T00:30:07Z"
        },
        {
          "author": "carrvo",
          "authorAssociation": "NONE",
          "body": "An example of displaying scope descriptions, but is hard-coded on the authorization server for a particular client is https://github.com/capjamesg/jamesg-indieauth",
          "createdAt": "2025-01-15T00:38:08Z",
          "updatedAt": "2025-01-15T00:38:08Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "body": "Scopes are ultimately defined by the resource server, so some authorization server products take a more \"hands off\" approach than others and either blindly pass through the client-requested scopes into the access token, or allow the admin to configure policies at the authorization server based on scopes. More typical consumer scenarios have the AS define and control everything having to do with scopes. But in any case, the client can't be the one providing the descriptions of the scopes to the end user, that defeats the entire purpose of the authorization server asking the user if it's ok for this client to get the scopes it asked for. If the client can provide its own descriptions of what it's asking for, the client could define the description of the \"delete\" scope as \"read-only access\" which would be shown by the AS on the consent screen. \r\n\r\n",
          "createdAt": "2025-01-15T00:49:56Z",
          "updatedAt": "2025-01-15T00:49:56Z"
        },
        {
          "author": "carrvo",
          "authorAssociation": "NONE",
          "body": "That is a lot more clear (especially the description of \"delete\" example). It suggests that I should be looking at passing a resource server ID (URL) so that the authorization server can find the descriptions from the appropriate source, and potentially return it as an `aud` claim too. So my idea is still valid, just needs to be a different server's metadata.",
          "createdAt": "2025-01-15T22:50:23Z",
          "updatedAt": "2025-01-15T22:50:23Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "body": "Yep, two links to point you in the right direction:\r\n\r\n* [Resource Server Metadata](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-resource-metadata) (although it does not provide a means to include a description of the scopes, just the scopes values themselves)\r\n* [Resource Indicators](https://www.rfc-editor.org/rfc/rfc8707) (adds a `resource` parameter to the authorization request like you described)",
          "createdAt": "2025-01-16T00:09:12Z",
          "updatedAt": "2025-01-16T00:09:12Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDOL_Xevs6lvLUb",
      "title": "Add guidance on CORS for Client Metadata Documents",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/28",
      "state": "OPEN",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I recently saw a developer thinking that their Client Metadata Document needed to be served with the following CORS headers:\r\n\r\n```\r\n// Add CORS headers to allow Bluesky to fetch our metadata\r\n\"Access-Control-Allow-Origin\": \"*\",\r\n\"Access-Control-Allow-Methods\": \"GET, OPTIONS\",\r\n```\r\n\r\nThis shouldn't be necessary unless Bluesky is making requests directly to the client metadata document client-side, though, we'd probably always encourage proxied access (i.e., retrieving the documents' values from the authorization server, not requesting to 3rd-party URLs)",
      "createdAt": "2025-01-10T16:35:56Z",
      "updatedAt": "2025-01-14T16:02:17Z",
      "closedAt": null,
      "comments": [
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "`GET` requests like this should not be pre-flighted though. Or am I missing something ?\r\n \r\nSimilarly, it seems odd that a browser app needs to download the client metadata. It would probably be more efficient to \"burn\" the needed values in the browser app at build time. And even if the client app did request the client metadata, it is a client implementation detail how these metadata are made available.\r\n\r\nSince the client metadata document is actually only really meant to be loaded from an oauth server, I would even argue that CORS requests from unknown origins should blocked. There is no point in allowing to load a client metadata from a web browser on a third party origin.\r\n\r\nWe could even require the server hosting the document to check for `sec-fetch-*` headers to prevent being loaded from a browser on an unknown origin.",
          "createdAt": "2025-01-14T14:35:36Z",
          "updatedAt": "2025-01-14T14:40:38Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure, there isn't any reason I can think of that a page in the browser would need to GET the client metadata document, unless someone was doing something unsafe on the authorization server side.",
          "createdAt": "2025-01-14T16:02:15Z",
          "updatedAt": "2025-01-14T16:02:15Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "I_kwDOL_Xevs6m0JGa",
      "title": "Client metadata retrieval can be abused to make server issued requests",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/30",
      "state": "OPEN",
      "author": "matthieusieben",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This issue was initially reported by @DavidBuchanan314 in https://github.com/bluesky-social/atproto/issues/3396.\n\nIn a federated network, in which hosts are known (as are PDS in the atproto network), the fact that OAuth Server will try to `GET` the client metadata can be used to faking traffic from a bunch of fake IPs, simply by forging authorization requests using the `client_id` as parameter.\n\nFor example, by forging the following requests:\n\n- `https://<pds_1>/oauth/authorize?client_id=https://example.com/page_1&...`\n- `https://<pds_2>/oauth/authorize?client_id=https://example.com/page_1&...`\n- `https://<pds_3>/oauth/authorize?client_id=https://example.com/page_1&...`\n\nThe website at `https://example.com/page_1` will see `GET` traffic from the IPs of all those hosts.\n\nPossible mitigations:\n- Retrieve the metadata document *after* the user authorized the request (though that could lead to weird UX & DX)\n- Add strong constraint on the URI format (eg. `.well-known`, \"must end with `.json`\", other...)\n- ~Recommend OAuth servers to remember the origins of previously failed metadata document retrieval, and prevent more call to be made on these origins~ (redacted: could be abused to cause DoS on legitimate services)\n- Other",
      "createdAt": "2025-01-20T09:23:25Z",
      "updatedAt": "2025-01-20T13:32:26Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidBuchanan314",
          "authorAssociation": "NONE",
          "body": "I don't think delaying the retrieval needs to have weird UX - It doesn't need to be be delayed until after authorization as a whole, just the initial user authentication phase.\n\nConsider a hypothetical sequence of events when `https://<pds_1>/oauth/authorize?client_id=https://example.com/page_1&...` is visited in a fresh browser session with no cookies, by a legitimate user of `<pds_1>` (but `example.com` is not a valid client application):\n\n1. Browser navigates to `https://<pds_1>/oauth/authorize?client_id=https://example.com/page_1&...`\n2. User is presented with a login form (at this point they're logging into their PDS itself, not authorizing a client application, yet).\n3. User submits their credentials to the PDS (i.e. the authorization server).\n4. The authorization server verifies the user's credentials, and *then* fetches `https://example.com/page_1`.\n5. The user is presented with an error message (since `https://example.com/page_1` was not valid client metadata) (if the metadata *was* valid, this is when the user would be prompted to grant the necessary scopes)\n\nThe user had to wait a few extra steps before seeing an error message (as opposed to immediately), but this flow should be rare in the first place - I can only see it happening to normal users if there was a bug in a legitimate client application that caused its client metadata to become invalid/unavailable. If the user already had a valid session cookie with the PDS (\"remember me on this device\"), they'd still get to see the error message immediately.\n\nOn the happy path (where the client_id resolved to valid client metadata) there shouldn't be any change to the UX at all.\n\nI'm implementing my deferred-retrieval approach here https://github.com/DavidBuchanan314/millipds/pull/42 (currently very WIP, messy code with lots of missing checks and validation - but the main flow is there)\n\nI'd also be in favour of stronger constraints on the URI (`.well-known` in particular, now that you mention it), since it would give greater peace of mind with respect to mitigating SSRF etc. (mitigating SSRF properly is fiddly and is often done wrong)",
          "createdAt": "2025-01-20T11:22:16Z",
          "updatedAt": "2025-01-20T11:22:16Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Could this possibly be a bit of a weird interplay between PAR and this I-D? I think PAR would mandate fetching during creation of the PAR (since iirc it needs to verify scopes and such whilst creating the PAR)\n\nNormally I'd say that it should happen pre-Authorization, i.e., during the `GET /oauth/authorize` request handling, which is at point of user interaction.\n\nThe AS is free to (and encouraged to cache responses), though we do currently say errors shouldn't be cached. Maybe we should change that to specify HTTP 4xx errors should be cached?\n\nWe've already changed the request for metadata to a \"MUST return HTTP 200 Ok\"",
          "createdAt": "2025-01-20T12:27:55Z",
          "updatedAt": "2025-01-20T12:27:55Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "Well, I guess that even with PAR, the metadata validation (including scopes verification) could be deferred to the authorization process.\n\nThe \"weird UX\" I'm referring to is more of a \"weired DX\". The client developer won't get a properly formatted `error` & `error_description` error response (during PAR, or as authorization response). Instead, they would get a visual error during the OAuth flow. This might be fine if we agree that causing un-wanted HTTP traffic to be generated from the server is a worse thing.",
          "createdAt": "2025-01-20T12:48:53Z",
          "updatedAt": "2025-01-20T12:49:29Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Wouldn't the PAR request itself fetch the client metadata document if necessary? So you could track failed par requests per IP & ban them, and also return the error at that point.\n\nThough for non-PAR, yes, the flow is usually \"fetch the document during authorisation flow post authentication\" ",
          "createdAt": "2025-01-20T12:54:33Z",
          "updatedAt": "2025-01-20T12:54:33Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "PAR can be seen as \"just\" a way to send the authorizations parameters to the servers using a POST request instead of GET query string parameters. The validation of the PAR parameters could technically still be delayed, including banning some IP based on the auth flow result.\n\nAnother \"Weird\" behavior that users might encounter is that the [authorization interface](https://www.oauth.com/oauth2-servers/authorization/requiring-user-login/) typically shows: \"Authorize app XYZ to access your account\".\n\nShowing the app name before the user logs in would not be doable without fetching the metadata.\n",
          "createdAt": "2025-01-20T13:01:33Z",
          "updatedAt": "2025-01-20T13:04:27Z"
        },
        {
          "author": "DavidBuchanan314",
          "authorAssociation": "NONE",
          "body": "Perhaps validation could be done early *if* the client metadata (or failure response) is already cached. This would improve DX marginally, in that you'd get a better error message on the second attempt.\n\nThe current [atproto oauth docs](https://atproto.com/specs/oauth) mention:\n\n>  Service operators may maintain a list of \"trusted\" client_id values and display the extra metadata for those apps only.\n\nYou could do the \"Authorize app XYZ to access your account\" UI pre-login only for these trusted apps (or maybe any \"seen before\" app). The message for unrecognized apps can be something a bit more \"scary\" and that's probably a good thing.",
          "createdAt": "2025-01-20T13:09:59Z",
          "updatedAt": "2025-01-20T13:09:59Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "When it comes to caching, I guess that the first thing would be to try and respect `cache-control` headers (though an attacker could bypass the cache by overloading it so that the targetted url gets eventually evicted from the cache). Legitimate client devs can use short TTL for the document metadata.\n\nThe issue here, I guess, is with 200 OK - NON JSON - responses (either without `cache-control`, or with URL that got evicted from the cache). If the response is 200 OK but obviously not a JSON metadata document, the related ~`origin`~ `URL` (redacted, see [comment bellow](https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/30#issuecomment-2602412248)) could be \"banned\" for some period of time, independent of the `cache-control`",
          "createdAt": "2025-01-20T13:12:59Z",
          "updatedAt": "2025-01-20T13:23:43Z"
        },
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "The \"trusted clients\" Atproto mentions means \"manually pre-approved by the PDS owner\", and not \"previously seen clients\".\n\nI don't like the idea of showing a different UX when a client is not known by a PDS as lamdba users will come to wonder why the interface is suddenly different. It could have pricacy implication too (e.g. on PDS with small number of users, you can determine if the other users have used some client by checking which UX you get when trying to use them yourself).",
          "createdAt": "2025-01-20T13:19:49Z",
          "updatedAt": "2025-01-20T13:19:49Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Banning by origin doesn't make much sense to me, as a single host _could_ have multiple client metadata documents served by it. \n\nTake for example the Development use case, if I send the request as `client_id=https://clients.atproto.dev/123` but my `client_id` generated was actually `https://clients.atproto.dev/456`, because 123 failed, you'd end up banning all of `clients.atproto.dev` even though it does actually have valid clients.",
          "createdAt": "2025-01-20T13:20:07Z",
          "updatedAt": "2025-01-20T13:20:24Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOL_Xevs5wl96g",
      "title": "Fix yaml frontmatter & prevent prettier from running",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/pull/1",
      "state": "MERGED",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Was starting to work on the draft, and was having compiling errors due to the yaml frontmatter having been incorrectly formatted by prettier (it really chokes on it), and the `url` property should've been `uri` from what I can tell.",
      "createdAt": "2024-05-26T16:03:37Z",
      "updatedAt": "2024-05-31T13:46:58Z",
      "baseRepository": "aaronpk/draft-parecki-oauth-client-id-metadata-document",
      "baseRefName": "main",
      "baseRefOid": "744111c3933074752580695018742b0811838636",
      "headRepository": "ThisIsMissEm/draft-parecki-oauth-client-id-metadata-document",
      "headRefName": "fix/prettier-and-yaml-frontmatter",
      "headRefOid": "37f38982d8ecfa22c55be6aa0766918977829544",
      "closedAt": "2024-05-31T13:46:58Z",
      "mergedAt": "2024-05-31T13:46:58Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "a9f57bdae4aa77069cb1856e49478d2a7e90f500"
      },
      "comments": [
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One thing I wasn't sure of is what the word-wrapping line length should be on this document? It'd be good to also specify this in the `.editorconfig`",
          "createdAt": "2024-05-26T16:26:19Z",
          "updatedAt": "2024-05-26T16:26:19Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 2,
      "id": "PR_kwDOL_Xevs5wmFhI",
      "title": "Suggested improvements",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/pull/2",
      "state": "MERGED",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is based on #1, but otherwise has a few language and spelling changes; Additionally:\r\n- added the section about the restriction on the `client_id` property strictly matching the client metadata document's URI\r\n- added recommendation to use a stable URL (I'm not sure if there's a spec to refer to, but it'd be bad practice to, for example, include a version number in the URL for cache busting purposes even though the contents of the document has not actually changed.\r\n- added TBD about possible verification endpoint (i.e., giving developers an easy way to verify their document is valid (or perhaps a mechanism to invalidate a previously cached document?)\r\n- added language to allow extensions to the client metadata document, and allowing it to be served as content types other than just `application/json`, e.g., `application/ld+json`\r\n- moved caching up to beneath errors, as to allow language to easily flow about requirements not to cache error responses or invalid documents.\r\n- added TBD question on the redirect URI matching and whether it is exact string matching or simple string comparison (the original language).\r\n- tried to use `client metadata document` more consistently.",
      "createdAt": "2024-05-26T17:00:57Z",
      "updatedAt": "2024-05-31T14:23:13Z",
      "baseRepository": "aaronpk/draft-parecki-oauth-client-id-metadata-document",
      "baseRefName": "main",
      "baseRefOid": "744111c3933074752580695018742b0811838636",
      "headRepository": "ThisIsMissEm/draft-parecki-oauth-client-id-metadata-document",
      "headRefName": "suggested-improvements",
      "headRefOid": "5f8f9354b8982b38f98f52a69f366264f1f1fc28",
      "closedAt": "2024-05-31T13:54:59Z",
      "mergedAt": "2024-05-31T13:54:59Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "ddd890557d6b4a6b4f4834f2a9cf0b46e4dcc6a5"
      },
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "body": "This is great, thanks. I'm going to merge it and open a few issues based on things I see here rather than hold up the merge.",
          "createdAt": "2024-05-31T13:54:56Z",
          "updatedAt": "2024-05-31T13:54:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOL_Xevs579mLh",
          "commit": {
            "abbreviatedOid": "095163b"
          },
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-26T17:01:42Z",
          "updatedAt": "2024-05-26T17:01:43Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "I moved the `MAY`s to the end, to hopefully improve clarity.",
              "createdAt": "2024-05-26T17:01:43Z",
              "updatedAt": "2024-05-26T17:01:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL_Xevs579nXw",
          "commit": {
            "abbreviatedOid": "095163b"
          },
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-26T17:04:32Z",
          "updatedAt": "2024-05-26T17:04:32Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "Would like to find some better language here, maybe referencing [Cool URIs](https://www.w3.org/Provider/Style/URI) is worthwhile?",
              "createdAt": "2024-05-26T17:04:32Z",
              "updatedAt": "2024-05-26T17:04:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL_Xevs579n3C",
          "commit": {
            "abbreviatedOid": "095163b"
          },
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-26T17:05:42Z",
          "updatedAt": "2024-05-26T17:05:42Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "This is necessary for security, as it prevents a redirect being used as a way to impersonate a client.\r\n\r\nTBD as to the algorithm for comparison: simple string comparison or exact string matching?",
              "createdAt": "2024-05-26T17:05:42Z",
              "updatedAt": "2024-05-26T17:05:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL_Xevs579ps_",
          "commit": {
            "abbreviatedOid": "095163b"
          },
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-26T17:21:34Z",
          "updatedAt": "2024-05-26T17:21:34Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "I'm not sure if I have the language here correct. But basically the idea is that authorization servers may reject specific client types or mandate that certain standard properties must be present and have a given value.",
              "createdAt": "2024-05-26T17:21:34Z",
              "updatedAt": "2024-05-26T17:21:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL_Xevs58oIdN",
          "commit": {
            "abbreviatedOid": "5f8f935"
          },
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-31T13:53:15Z",
          "updatedAt": "2024-05-31T13:53:15Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Maybe the AS should respect the HTTP cache headers that the client returns from the URL? Probably the AS should also have its own min/max cache lifetimes based on its own requirements as well.",
              "createdAt": "2024-05-31T13:53:15Z",
              "updatedAt": "2024-05-31T13:53:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL_Xevs58oeH3",
          "commit": {
            "abbreviatedOid": "5f8f935"
          },
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-31T14:23:13Z",
          "updatedAt": "2024-05-31T14:23:13Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "I was maybe thinking etags / if-unmodified-since type headers? I'm really not sure",
              "createdAt": "2024-05-31T14:23:13Z",
              "updatedAt": "2024-05-31T14:23:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOL_Xevs50jyAY",
      "title": "Feat: Maximum response size for Client Metadata Documents",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/pull/14",
      "state": "MERGED",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I did some research through other OAuth related specifications and couldn't find any similar language. I'm unsure if we should set an absolute maximum, but I think a recommendation of 5 kilobytes is probably sufficient for almost all use cases.\r\n\r\nI think typically these documents are under 1kb in size.\r\n\r\nResolves #9 ",
      "createdAt": "2024-07-05T18:29:10Z",
      "updatedAt": "2024-07-08T16:12:19Z",
      "baseRepository": "aaronpk/draft-parecki-oauth-client-id-metadata-document",
      "baseRefName": "main",
      "baseRefOid": "4acdf4744b8ab91ab77a186e2bf1c1901e365219",
      "headRepository": "ThisIsMissEm/draft-parecki-oauth-client-id-metadata-document",
      "headRefName": "feat/document-response-max-size",
      "headRefOid": "8d46176b64b72b7a2db09c487019bbef1b50ae30",
      "closedAt": "2024-07-08T16:12:19Z",
      "mergedAt": "2024-07-08T16:12:19Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "55b78eaa15323c61354812362c2b721e7a122380"
      },
      "comments": [
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One thing that may drive up the size of a client metadata document is full localisation of localisable properties in the document, given that the IANA language subtag registry includes several thousand languages: https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry\r\n\r\nSo maybe this limitation would actually be problematic, and we should just suggest something less than X megabytes, instead of kilobytes?\r\n\r\nAlthough, I don't think I've ever seen localisation used in practice.",
          "createdAt": "2024-07-05T20:17:38Z",
          "updatedAt": "2024-07-05T20:18:00Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "body": "The other option for localization is to use a different client ID per language, `https://example.com/id/en` `https://example.com/id/de` etc.\r\n\r\nThis is good enough for now , we can always change it later if we get more feedback.",
          "createdAt": "2024-07-08T16:12:16Z",
          "updatedAt": "2024-07-08T16:12:16Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 24,
      "id": "PR_kwDOL_Xevs6G33QO",
      "title": "Improve documentation for development usage, prohibiting query parameters in document URLs",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/pull/24",
      "state": "MERGED",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A pattern that we've seen sometimes used is to have a service generate Client ID Metadata Documents by taking in data from query parameters and transposing those into the contents of the document, this should probably be considered an anti-pattern, since it circumvents a fair few of the security properties of stable URLs for client id metadata documents.\r\n\r\nThis is noted in #23 and #12, where workarounds have tried to be developed.\r\n\r\nFor instance, for AtProto / Bluesky, they could host a `client_id.atproto.dev` service which allows you to preregistered a client for development purposes (specifying redirect_uris, scopes, etc), giving back a https URL to a document that you can use for that client.\r\n\r\nWe could expand this to allow a Authorization Server to apply additional constrains on the contents of the client metadata document, based on the hostname of the document itself, e.g., only documents on `client_id.atproto.dev` hostname can include redirect URIs that are localhost URIs.",
      "createdAt": "2025-01-06T23:13:20Z",
      "updatedAt": "2025-01-10T00:50:49Z",
      "baseRepository": "aaronpk/draft-parecki-oauth-client-id-metadata-document",
      "baseRefName": "main",
      "baseRefOid": "e2fa17b9615df7cb76e04a2a143f9b45fcd6fe00",
      "headRepository": "ThisIsMissEm/draft-parecki-oauth-client-id-metadata-document",
      "headRefName": "feat/improve-development-usage",
      "headRefOid": "e3a35cd4f9ee880b8acab2e1454ba2c4ebd38d4d",
      "closedAt": "2025-01-10T00:50:48Z",
      "mergedAt": "2025-01-10T00:50:48Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "d69da84351a89d8db86ee5c72703a10bd11d5965"
      },
      "comments": [
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@matthieusieben I think you may want to review this.",
          "createdAt": "2025-01-06T23:16:52Z",
          "updatedAt": "2025-01-06T23:16:52Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOL_Xevs6W_G_n",
          "commit": {
            "abbreviatedOid": "1dd3a57"
          },
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-06T23:14:50Z",
          "updatedAt": "2025-01-06T23:14:50Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "As far as I know, this isn't a relevant property, and `private_key_jwt` as mentioned in the Client Authentication Security Consideration does not have a \"expires at\", and `client_secret_expires_at` only is relevant for the `client_secret` property.",
              "createdAt": "2025-01-06T23:14:50Z",
              "updatedAt": "2025-01-06T23:14:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL_Xevs6W_HDk",
          "commit": {
            "abbreviatedOid": "1dd3a57"
          },
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-06T23:15:11Z",
          "updatedAt": "2025-01-06T23:15:11Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "We could also include:\r\n```suggestion\r\n* the `client_secret` and `client_secret_expires_at` properties MUST NOT be used\r\n```",
              "createdAt": "2025-01-06T23:15:11Z",
              "updatedAt": "2025-01-06T23:15:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL_Xevs6W_ICr",
          "commit": {
            "abbreviatedOid": "1dd3a57"
          },
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-06T23:20:06Z",
          "updatedAt": "2025-01-06T23:20:06Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "```suggestion\r\n## Client ID Metadata Documents for Development Purposes {#documents_for_development}\r\n```",
              "createdAt": "2025-01-06T23:20:06Z",
              "updatedAt": "2025-01-06T23:20:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL_Xevs6XeCrH",
          "commit": {
            "abbreviatedOid": "f3cabd0"
          },
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-10T00:31:57Z",
          "updatedAt": "2025-01-10T00:31:58Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Was it intentional to just remove the mention of a query string component, rather than say \"MUST NOT\" include a query string component?",
              "createdAt": "2025-01-10T00:31:57Z",
              "updatedAt": "2025-01-10T00:31:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL_Xevs6XeFQI",
          "commit": {
            "abbreviatedOid": "f3cabd0"
          },
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-10T00:36:19Z",
          "updatedAt": "2025-01-10T00:36:19Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "hmm, I'm not sure what would be best? maybe \"SHOULD NOT\" ? The idea is to discourage usage as much as possible.",
              "createdAt": "2025-01-10T00:36:19Z",
              "updatedAt": "2025-01-10T00:36:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL_Xevs6XeImz",
          "commit": {
            "abbreviatedOid": "f3cabd0"
          },
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-10T00:42:05Z",
          "updatedAt": "2025-01-10T00:42:05Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "\"SHOULD NOT\" would be in line with the comment here https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/23#issuecomment-2575500904",
              "createdAt": "2025-01-10T00:42:05Z",
              "updatedAt": "2025-01-10T00:42:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL_Xevs6XeJIg",
          "commit": {
            "abbreviatedOid": "f3cabd0"
          },
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-10T00:43:02Z",
          "updatedAt": "2025-01-10T00:43:02Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Let's add \"SHOULD NOT\" here and merge this in for publishing version -02 today",
              "createdAt": "2025-01-10T00:43:02Z",
              "updatedAt": "2025-01-10T00:43:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL_Xevs6XeKhQ",
          "commit": {
            "abbreviatedOid": "f3cabd0"
          },
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-10T00:45:35Z",
          "updatedAt": "2025-01-10T00:45:35Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nClient identifier URLs SHOULD NOT include a query string component, and MAY contain a port.\r\n```",
              "createdAt": "2025-01-10T00:45:35Z",
              "updatedAt": "2025-01-10T00:45:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 25,
      "id": "PR_kwDOL_Xevs6G38Le",
      "title": "Add security consideration for logo_uri usage",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/pull/25",
      "state": "MERGED",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'm not 100% happy with the wording here, but this does begin to address the concerns around displaying logos to end-users that are provided from within the client metadata document.\r\n\r\nThe idea is to provide a security consideration similar to the consideration in Dynamic Client Registration: https://www.rfc-editor.org/rfc/rfc7591.html#section-5\r\n\r\n> In a situation where the authorization server is supporting open client registration, it must be extremely careful with any URL provided by the client that will be displayed to the user (e.g., \"logo_uri\", \"tos_uri\", \"client_uri\", and \"policy_uri\").  For instance, a rogue client could specify a registration request with a reference to a drive-by download in the \"policy_uri\", enticing the user to click on it during the authorization.  The authorization server SHOULD check to see if the \"logo_uri\", \"tos_uri\", \"client_uri\", and \"policy_uri\" have the same host and scheme as the those defined in the array of \"redirect_uris\" and that all of these URIs resolve to valid web pages.  Since these URI values that are intended to be displayed to the user at the authorization page, the authorization server SHOULD protect the user from malicious content hosted at the URLs where possible.  For instance, before presenting the URLs to the user at the authorization page, the authorization server could download the content hosted at the URLs, check the content against a malware scanner and blacklist filter, determine whether or not there is mixed secure and non-secure content at the URL, and other possible server-side mitigations.  Note that the content in these URLs can change at any time and the authorization server cannot provide complete confidence in the safety of the URLs, but these practices could help.  To further mitigate this kind of threat, the authorization server can also warn the user that the URL links have been provided by a third party, should be treated with caution, and are not hosted by the authorization server itself.  For instance, instead of providing the links directly in an HTML anchor, the authorization server can direct the user to an interstitial warning page before allowing the user to continue to the target URL\r\n\r\nPerhaps the section should be also including `tos_uri`, `policy_uri` and `client_uri` (e.g., asserting that the Authorization Server can choose to validate the documents at these URIs and also choose whether or not to display these URIs to the end-user.",
      "createdAt": "2025-01-06T23:38:22Z",
      "updatedAt": "2025-01-10T00:33:02Z",
      "baseRepository": "aaronpk/draft-parecki-oauth-client-id-metadata-document",
      "baseRefName": "main",
      "baseRefOid": "bab0ab4639cf551b97cfec860b0512a55927d790",
      "headRepository": "ThisIsMissEm/draft-parecki-oauth-client-id-metadata-document",
      "headRefName": "feat/add-consideration-for-logo_uri",
      "headRefOid": "8fc35a65f0381e6b6ab3675b2cf3b5914e193289",
      "closedAt": "2025-01-10T00:33:02Z",
      "mergedAt": "2025-01-10T00:33:02Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "6158b5ef98a28272cfe77ed496f7dcfad53cedb3"
      },
      "comments": [
        {
          "author": "matthieusieben",
          "authorAssociation": "NONE",
          "body": "Note that if we mention caching of those extra resources, the \"[Maximum Response Size for Client Metadata Documents](http://drafts.aaronpk.com/draft-parecki-oauth-client-id-metadata-document/draft-parecki-oauth-client-id-metadata-document.html#name-maximum-response-size-for-c)\" section should also be updated to account for those resources.",
          "createdAt": "2025-01-07T15:03:55Z",
          "updatedAt": "2025-01-07T15:03:55Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@matthieusieben the maximum response size is only for the metadata document itself, not any image resources referenced by it. For those, you would likely need to determine your own appropriate limits. (I'd say < 1mb)",
          "createdAt": "2025-01-07T18:00:31Z",
          "updatedAt": "2025-01-07T18:00:31Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "OWNER",
          "body": "I think this is a good start in any case.",
          "createdAt": "2025-01-10T00:32:59Z",
          "updatedAt": "2025-01-10T00:32:59Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 29,
      "id": "PR_kwDOL_Xevs6HYRv_",
      "title": "Improve documentation for development usage and expiration of clients",
      "url": "https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/pull/29",
      "state": "OPEN",
      "author": "ThisIsMissEm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is as was discussed in https://github.com/aaronpk/draft-parecki-oauth-client-id-metadata-document/issues/23#issuecomment-2583274006\r\n\r\nI did also add the restriction that the client metadata document response must be with a HTTP 200 OK status code, i.e., 3xx or 201 or other status codes should not be considered valid.\r\n\r\nAlso moved the development purposes section up from Security Considerations to the main part of the document.",
      "createdAt": "2025-01-10T20:15:10Z",
      "updatedAt": "2025-01-10T20:16:03Z",
      "baseRepository": "aaronpk/draft-parecki-oauth-client-id-metadata-document",
      "baseRefName": "main",
      "baseRefOid": "d69da84351a89d8db86ee5c72703a10bd11d5965",
      "headRepository": "ThisIsMissEm/draft-parecki-oauth-client-id-metadata-document",
      "headRefName": "feat/client-revocation",
      "headRefOid": "7de39c44c0cdab97f572c27b521d3848a5fd6653",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOL_Xevs6XnXwG",
          "commit": {
            "abbreviatedOid": "7de39c4"
          },
          "author": "ThisIsMissEm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-10T20:16:02Z",
          "updatedAt": "2025-01-10T20:16:03Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I am really strongly encouraging this over the alternative of just sticking the document anywhere on the web with a public URL for development purposes.",
              "createdAt": "2025-01-10T20:16:02Z",
              "updatedAt": "2025-01-10T20:16:03Z"
            }
          ]
        }
      ]
    }
  ]
}